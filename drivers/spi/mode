./spi-cadence.c:	return readl_relaxed(xspi->regs + offset);
./spi-cadence.c:	writel_relaxed(val, xspi->regs + offset);
./spi-cadence.c:	if (xspi->is_decoded_cs)
./spi-cadence.c:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
./spi-cadence.c:		if (!(xspi->is_decoded_cs))
./spi-cadence.c:			ctrl_reg |= ((~(CDNS_SPI_SS0 << spi->chip_select)) <<
./spi-cadence.c:			ctrl_reg |= (spi->chip_select << CDNS_SPI_SS_SHIFT) &
./spi-cadence.c:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
./spi-cadence.c:	if (spi->mode & SPI_CPHA)
./spi-cadence.c:	if (spi->mode & SPI_CPOL)
./spi-cadence.c:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
./spi-cadence.c:	frequency = clk_get_rate(xspi->ref_clk);
./spi-cadence.c:	if (xspi->speed_hz != transfer->speed_hz) {
./spi-cadence.c:		xspi->speed_hz = frequency / (2 << baud_rate_val);
./spi-cadence.c:	struct cdns_spi *xspi = spi_master_get_devdata(spi->master);
./spi-cadence.c:	dev_dbg(&spi->dev, "%s, mode %d, %u bits/w, %u clock speed\n",
./spi-cadence.c:		__func__, spi->mode, spi->bits_per_word,
./spi-cadence.c:		xspi->speed_hz);
./spi-cadence.c:	       (xspi->tx_bytes > 0)) {
./spi-cadence.c:		if (xspi->txbuf)
./spi-cadence.c:				       *xspi->txbuf++);
./spi-cadence.c:		xspi->tx_bytes--;
./spi-cadence.c:		trans_cnt = xspi->rx_bytes - xspi->tx_bytes;
./spi-cadence.c:			if (xspi->rxbuf)
./spi-cadence.c:				*xspi->rxbuf++ = data;
./spi-cadence.c:			xspi->rx_bytes--;
./spi-cadence.c:		if (xspi->tx_bytes) {
./spi-cadence.c:	xspi->txbuf = transfer->tx_buf;
./spi-cadence.c:	xspi->rxbuf = transfer->rx_buf;
./spi-cadence.c:	xspi->tx_bytes = transfer->len;
./spi-cadence.c:	xspi->rx_bytes = transfer->len;
./spi-cadence.c:	xspi->regs = devm_ioremap_resource(&pdev->dev, res);
./spi-cadence.c:	if (IS_ERR(xspi->regs)) {
./spi-cadence.c:		ret = PTR_ERR(xspi->regs);
./spi-cadence.c:	xspi->pclk = devm_clk_get(&pdev->dev, "pclk");
./spi-cadence.c:	if (IS_ERR(xspi->pclk)) {
./spi-cadence.c:		ret = PTR_ERR(xspi->pclk);
./spi-cadence.c:	xspi->ref_clk = devm_clk_get(&pdev->dev, "ref_clk");
./spi-cadence.c:	if (IS_ERR(xspi->ref_clk)) {
./spi-cadence.c:		ret = PTR_ERR(xspi->ref_clk);
./spi-cadence.c:	ret = clk_prepare_enable(xspi->pclk);
./spi-cadence.c:	ret = clk_prepare_enable(xspi->ref_clk);
./spi-cadence.c:				   &xspi->is_decoded_cs);
./spi-cadence.c:		xspi->is_decoded_cs = 0;
./spi-cadence.c:	master->max_speed_hz = clk_get_rate(xspi->ref_clk) / 4;
./spi-cadence.c:	xspi->speed_hz = master->max_speed_hz;
./spi-cadence.c:	clk_disable_unprepare(xspi->ref_clk);
./spi-cadence.c:	clk_disable_unprepare(xspi->pclk);
./spi-cadence.c:	clk_disable_unprepare(xspi->ref_clk);
./spi-cadence.c:	clk_disable_unprepare(xspi->pclk);
./spi-cadence.c:	clk_disable_unprepare(xspi->ref_clk);
./spi-cadence.c:	clk_disable_unprepare(xspi->pclk);
./spi-cadence.c:	ret = clk_prepare_enable(xspi->pclk);
./spi-cadence.c:	ret = clk_prepare_enable(xspi->ref_clk);
./spi-cadence.c:		clk_disable(xspi->pclk);
./spi-cadence.c:	{ .compatible = "xlnx,zynq-spi-r1p6" },
./spi-cadence.c:	{ .compatible = "cdns,spi-r1p6" },
./spi-ath79.c: * This driver has been based on the spi-gpio.c:
./spi-ath79.c:	return spi_master_get_devdata(spi->master);
./spi-ath79.c:	int cs_high = (spi->mode & SPI_CS_HIGH) ? is_active : !is_active;
./spi-ath79.c:		if (spi->mode & SPI_CPOL)
./spi-ath79.c:	if (spi->chip_select) {
./spi-ath79.c:		struct ath79_spi_controller_data *cdata = spi->controller_data;
./spi-ath79.c:	cdata = spi->controller_data;
./spi-ath79.c:	if (spi->chip_select && !cdata)
./spi-ath79.c:	if (spi->chip_select) {
./spi-ath79.c:		if (spi->mode & SPI_CS_HIGH)
./spi-ath79.c:					  dev_name(&spi->dev));
./spi-ath79.c:	if (spi->chip_select) {
./spi-ath79.c:		struct ath79_spi_controller_data *cdata = spi->controller_data;
./spi-ath79.c:	if (!spi->controller_state) {
./spi-ath79.c:	if (status && !spi->controller_state)
Binary file ./spi.o matches
./spi-imx.c:#include <linux/platform_data/spi-imx.h>
./spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
./spi-imx.c:	int gpio = spi_imx->chipselect[spi->chip_select];
./spi-imx.c:	int dev_is_lowactive = !(spi->mode & SPI_CS_HIGH);
./spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
./spi-imx.c:	config.bpw = t ? t->bits_per_word : spi->bits_per_word;
./spi-imx.c:	config.speed_hz  = t ? t->speed_hz : spi->max_speed_hz;
./spi-imx.c:	config.mode = spi->mode;
./spi-imx.c:	config.cs = spi->chip_select;
./spi-imx.c:		config.speed_hz = spi->max_speed_hz;
./spi-imx.c:		config.bpw = spi->bits_per_word;
./spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
./spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
./spi-imx.c:	struct spi_imx_data *spi_imx = spi_master_get_devdata(spi->master);
./spi-imx.c:	int gpio = spi_imx->chipselect[spi->chip_select];
./spi-imx.c:	dev_dbg(&spi->dev, "%s: mode %d, %u bpw, %d hz\n", __func__,
./spi-imx.c:		 spi->mode, spi->bits_per_word, spi->max_speed_hz);
./spi-imx.c:		gpio_direction_output(gpio, spi->mode & SPI_CS_HIGH ? 0 : 1);
./spi-imx.c:	ret = of_property_read_u32(np, "fsl,spi-num-chipselects", &num_cs);
./spi-s3c64xx.c:#include <linux/platform_data/spi-s3c64xx.h>
./spi-s3c64xx.c:		spi->dma_rx = sdd->rx_dma.ch;
./spi-s3c64xx.c:		spi->dma_tx = sdd->tx_dma.ch;
./spi-s3c64xx.c:	struct s3c64xx_spi_csinfo *cs = spi->controller_data;
./spi-s3c64xx.c:	if (sdd->cur_speed != spi->max_speed_hz
./spi-s3c64xx.c:			|| sdd->cur_mode != spi->mode
./spi-s3c64xx.c:			|| sdd->cur_bpw != spi->bits_per_word) {
./spi-s3c64xx.c:		sdd->cur_bpw = spi->bits_per_word;
./spi-s3c64xx.c:		sdd->cur_speed = spi->max_speed_hz;
./spi-s3c64xx.c:		sdd->cur_mode = spi->mode;
./spi-s3c64xx.c:	speed = xfer->speed_hz ? : spi->max_speed_hz;
./spi-s3c64xx.c:		dev_err(&spi->dev, "I/O Error: rx-%d tx-%d res:rx-%c tx-%c len-%d\n",
./spi-s3c64xx.c:	slave_np = spi->dev.of_node;
./spi-s3c64xx.c:		dev_err(&spi->dev, "device node not found\n");
./spi-s3c64xx.c:		dev_err(&spi->dev, "child node 'controller-data' not found\n");
./spi-s3c64xx.c:	of_property_read_u32(data_np, "samsung,spi-feedback-delay", &fb_delay);
./spi-s3c64xx.c:	struct s3c64xx_spi_csinfo *cs = spi->controller_data;
./spi-s3c64xx.c:	sdd = spi_master_get_devdata(spi->master);
./spi-s3c64xx.c:	if (spi->dev.of_node) {
./spi-s3c64xx.c:		spi->controller_data = cs;
./spi-s3c64xx.c:		/* On non-DT platforms the SPI core will set spi->cs_gpio
./spi-s3c64xx.c:		 * is defined by using platform data so spi->cs_gpio value
./spi-s3c64xx.c:		spi->cs_gpio = cs->line;
./spi-s3c64xx.c:		dev_err(&spi->dev, "No CS for SPI(%d)\n", spi->chip_select);
./spi-s3c64xx.c:		if (gpio_is_valid(spi->cs_gpio)) {
./spi-s3c64xx.c:			err = gpio_request_one(spi->cs_gpio, GPIOF_OUT_INIT_HIGH,
./spi-s3c64xx.c:					       dev_name(&spi->dev));
./spi-s3c64xx.c:				dev_err(&spi->dev,
./spi-s3c64xx.c:					spi->cs_gpio, err);
./spi-s3c64xx.c:		if (spi->max_speed_hz > speed)
./spi-s3c64xx.c:			spi->max_speed_hz = speed;
./spi-s3c64xx.c:		psr = clk_get_rate(sdd->src_clk) / 2 / spi->max_speed_hz - 1;
./spi-s3c64xx.c:		if (spi->max_speed_hz < speed) {
./spi-s3c64xx.c:		if (spi->max_speed_hz >= speed) {
./spi-s3c64xx.c:			spi->max_speed_hz = speed;
./spi-s3c64xx.c:			dev_err(&spi->dev, "Can't set %dHz transfer speed\n",
./spi-s3c64xx.c:				spi->max_speed_hz);
./spi-s3c64xx.c:	if (gpio_is_valid(spi->cs_gpio))
./spi-s3c64xx.c:		gpio_free(spi->cs_gpio);
./spi-s3c64xx.c:	if (spi->dev.of_node)
./spi-s3c64xx.c:	if (gpio_is_valid(spi->cs_gpio)) {
./spi-s3c64xx.c:		gpio_free(spi->cs_gpio);
./spi-s3c64xx.c:		if (spi->dev.of_node)
./spi-s3c64xx.c:			 * spi->cs_gpio to -ENOENT and .setup()
./spi-s3c64xx.c:			spi->cs_gpio = -ENOENT;
./spi-s3c64xx.c:		dev_err(&spi->dev, "RX overrun\n");
./spi-s3c64xx.c:		dev_err(&spi->dev, "RX underrun\n");
./spi-s3c64xx.c:		dev_err(&spi->dev, "TX overrun\n");
./spi-s3c64xx.c:		dev_err(&spi->dev, "TX underrun\n");
./spi-s3c64xx.c:	if (of_property_read_u32(dev->of_node, "samsung,spi-src-clk", &temp)) {
./spi-s3c64xx.c:	/* the spi->mode bits understood by this driver: */
./spi-s3c64xx.c:				"spi-s3c64xx", sdd);
./Makefile:obj-$(CONFIG_SPI_ALTERA)		+= spi-altera.o
./Makefile:obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
./Makefile:obj-$(CONFIG_SPI_ATH79)			+= spi-ath79.o
./Makefile:obj-$(CONFIG_SPI_AU1550)		+= spi-au1550.o
./Makefile:obj-$(CONFIG_SPI_BCM2835)		+= spi-bcm2835.o
./Makefile:obj-$(CONFIG_SPI_BCM53XX)		+= spi-bcm53xx.o
./Makefile:obj-$(CONFIG_SPI_BCM63XX)		+= spi-bcm63xx.o
./Makefile:obj-$(CONFIG_SPI_BCM63XX_HSSPI)		+= spi-bcm63xx-hsspi.o
./Makefile:obj-$(CONFIG_SPI_BFIN5XX)		+= spi-bfin5xx.o
./Makefile:obj-$(CONFIG_SPI_ADI_V3)                += spi-adi-v3.o
./Makefile:obj-$(CONFIG_SPI_BFIN_SPORT)		+= spi-bfin-sport.o
./Makefile:obj-$(CONFIG_SPI_BITBANG)		+= spi-bitbang.o
./Makefile:obj-$(CONFIG_SPI_BUTTERFLY)		+= spi-butterfly.o
./Makefile:obj-$(CONFIG_SPI_CADENCE)		+= spi-cadence.o
./Makefile:obj-$(CONFIG_SPI_CLPS711X)		+= spi-clps711x.o
./Makefile:obj-$(CONFIG_SPI_COLDFIRE_QSPI)		+= spi-coldfire-qspi.o
./Makefile:obj-$(CONFIG_SPI_DAVINCI)		+= spi-davinci.o
./Makefile:obj-$(CONFIG_SPI_DLN2)			+= spi-dln2.o
./Makefile:obj-$(CONFIG_SPI_DESIGNWARE)		+= spi-dw.o
./Makefile:obj-$(CONFIG_SPI_DW_MMIO)		+= spi-dw-mmio.o
./Makefile:obj-$(CONFIG_SPI_DW_PCI)		+= spi-dw-midpci.o
./Makefile:spi-dw-midpci-objs			:= spi-dw-pci.o spi-dw-mid.o
./Makefile:obj-$(CONFIG_SPI_EFM32)			+= spi-efm32.o
./Makefile:obj-$(CONFIG_SPI_EP93XX)		+= spi-ep93xx.o
./Makefile:obj-$(CONFIG_SPI_FALCON)		+= spi-falcon.o
./Makefile:obj-$(CONFIG_SPI_FSL_CPM)		+= spi-fsl-cpm.o
./Makefile:obj-$(CONFIG_SPI_FSL_DSPI)		+= spi-fsl-dspi.o
./Makefile:obj-$(CONFIG_SPI_FSL_LIB)		+= spi-fsl-lib.o
./Makefile:obj-$(CONFIG_SPI_FSL_ESPI)		+= spi-fsl-espi.o
./Makefile:obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
./Makefile:obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
./Makefile:obj-$(CONFIG_SPI_IMG_SPFI)		+= spi-img-spfi.o
./Makefile:obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
./Makefile:obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
./Makefile:obj-$(CONFIG_SPI_MESON_SPIFC)		+= spi-meson-spifc.o
./Makefile:obj-$(CONFIG_SPI_MPC512x_PSC)		+= spi-mpc512x-psc.o
./Makefile:obj-$(CONFIG_SPI_MPC52xx_PSC)		+= spi-mpc52xx-psc.o
./Makefile:obj-$(CONFIG_SPI_MPC52xx)		+= spi-mpc52xx.o
./Makefile:obj-$(CONFIG_SPI_MXS)			+= spi-mxs.o
./Makefile:obj-$(CONFIG_SPI_NUC900)		+= spi-nuc900.o
./Makefile:obj-$(CONFIG_SPI_OC_TINY)		+= spi-oc-tiny.o
./Makefile:obj-$(CONFIG_SPI_OCTEON)		+= spi-octeon.o
./Makefile:obj-$(CONFIG_SPI_OMAP_UWIRE)		+= spi-omap-uwire.o
./Makefile:obj-$(CONFIG_SPI_OMAP_100K)		+= spi-omap-100k.o
./Makefile:obj-$(CONFIG_SPI_OMAP24XX)		+= spi-omap2-mcspi.o
./Makefile:obj-$(CONFIG_SPI_TI_QSPI)		+= spi-ti-qspi.o
./Makefile:obj-$(CONFIG_SPI_ORION)			+= spi-orion.o
./Makefile:obj-$(CONFIG_SPI_PL022)			+= spi-pl022.o
./Makefile:obj-$(CONFIG_SPI_PPC4xx)		+= spi-ppc4xx.o
./Makefile:spi-pxa2xx-platform-objs		:= spi-pxa2xx.o
./Makefile:spi-pxa2xx-platform-$(CONFIG_SPI_PXA2XX_PXADMA)	+= spi-pxa2xx-pxadma.o
./Makefile:spi-pxa2xx-platform-$(CONFIG_SPI_PXA2XX_DMA)	+= spi-pxa2xx-dma.o
./Makefile:obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-platform.o
./Makefile:obj-$(CONFIG_SPI_PXA2XX_PCI)		+= spi-pxa2xx-pci.o
./Makefile:obj-$(CONFIG_SPI_QUP)			+= spi-qup.o
./Makefile:obj-$(CONFIG_SPI_ROCKCHIP)		+= spi-rockchip.o
./Makefile:obj-$(CONFIG_SPI_RSPI)			+= spi-rspi.o
./Makefile:obj-$(CONFIG_SPI_S3C24XX)		+= spi-s3c24xx-hw.o
./Makefile:spi-s3c24xx-hw-y			:= spi-s3c24xx.o
./Makefile:spi-s3c24xx-hw-$(CONFIG_SPI_S3C24XX_FIQ) += spi-s3c24xx-fiq.o
./Makefile:obj-$(CONFIG_SPI_S3C64XX)		+= spi-s3c64xx.o
./Makefile:obj-$(CONFIG_SPI_SC18IS602)		+= spi-sc18is602.o
./Makefile:obj-$(CONFIG_SPI_SH)			+= spi-sh.o
./Makefile:obj-$(CONFIG_SPI_SH_HSPI)		+= spi-sh-hspi.o
./Makefile:obj-$(CONFIG_SPI_SH_MSIOF)		+= spi-sh-msiof.o
./Makefile:obj-$(CONFIG_SPI_SH_SCI)		+= spi-sh-sci.o
./Makefile:obj-$(CONFIG_SPI_SIRF)		+= spi-sirf.o
./Makefile:obj-$(CONFIG_SPI_ST_SSC4)		+= spi-st-ssc4.o
./Makefile:obj-$(CONFIG_SPI_SUN4I)			+= spi-sun4i.o
./Makefile:obj-$(CONFIG_SPI_SUN6I)			+= spi-sun6i.o
./Makefile:obj-$(CONFIG_SPI_TEGRA114)		+= spi-tegra114.o
./Makefile:obj-$(CONFIG_SPI_TEGRA20_SFLASH)	+= spi-tegra20-sflash.o
./Makefile:obj-$(CONFIG_SPI_TEGRA20_SLINK)		+= spi-tegra20-slink.o
./Makefile:obj-$(CONFIG_SPI_TLE62X0)		+= spi-tle62x0.o
./Makefile:obj-$(CONFIG_SPI_TOPCLIFF_PCH)		+= spi-topcliff-pch.o
./Makefile:obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
./Makefile:obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
./Makefile:obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
./Makefile:obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
./spi-tle62x0.c:	pdata = dev_get_platdata(&spi->dev);
./spi-tle62x0.c:		dev_err(&spi->dev, "no device data specified\n");
./spi-tle62x0.c:	ret = device_create_file(&spi->dev, &dev_attr_status_show);
./spi-tle62x0.c:		dev_err(&spi->dev, "cannot create status attribute\n");
./spi-tle62x0.c:		ret = device_create_file(&spi->dev, gpio_attrs[ptr]);
./spi-tle62x0.c:			dev_err(&spi->dev, "cannot create gpio attribute\n");
./spi-tle62x0.c:		device_remove_file(&spi->dev, gpio_attrs[ptr]);
./spi-tle62x0.c:	device_remove_file(&spi->dev, &dev_attr_status_show);
./spi-tle62x0.c:		device_remove_file(&spi->dev, gpio_attrs[ptr]);
./spi-tle62x0.c:	device_remove_file(&spi->dev, &dev_attr_status_show);
./modules.builtin:kernel/drivers/spi/spi-fsl-dspi.ko
Binary file ./built-in.o matches
./spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi_cs *cs = spi->controller_state;
./spi-mpc52xx-psc.c:			? t->speed_hz : spi->max_speed_hz;
./spi-mpc52xx-psc.c:			? t->bits_per_word : spi->bits_per_word;
./spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi_cs *cs = spi->controller_state;
./spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
./spi-mpc52xx-psc.c:	if (spi->mode & SPI_CPHA)
./spi-mpc52xx-psc.c:	if (spi->mode & SPI_CPOL)
./spi-mpc52xx-psc.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-mpc52xx-psc.c:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 1 : 0);
./spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
./spi-mpc52xx-psc.c:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 0 : 1);
./spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
./spi-mpc52xx-psc.c:		dev_dbg(&spi->dev, "send %d bytes...\n", send_at_once);
./spi-mpc52xx-psc.c:		dev_dbg(&spi->dev, "%d bytes received\n", recv_at_once);
./spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
./spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi_cs *cs = spi->controller_state;
./spi-mpc52xx-psc.c:	if (spi->bits_per_word%8)
./spi-mpc52xx-psc.c:		spi->controller_state = cs;
./spi-mpc52xx-psc.c:	cs->bits_per_word = spi->bits_per_word;
./spi-mpc52xx-psc.c:	cs->speed_hz = spi->max_speed_hz;
./spi-mpc52xx-psc.c:	struct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);
./spi-mpc52xx-psc.c:	kfree(spi->controller_state);
./spi-mpc52xx-psc.c:	/* the spi->mode bits understood by this driver: */
./spi-dln2.c:	if (dln2->cs != spi->chip_select) {
./spi-dln2.c:		ret = dln2_spi_cs_set_one(dln2, spi->chip_select);
./spi-dln2.c:		dln2->cs = spi->chip_select;
./spi-dln2.c:					 spi->mode);
./spi-omap2-mcspi.c:#include <linux/platform_data/spi-omap2-mcspi.h>
./spi-omap2-mcspi.c:	writel_relaxed(val, mcspi->base + idx);
./spi-omap2-mcspi.c:	return readl_relaxed(mcspi->base + idx);
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs *cs = spi->controller_state;
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs *cs = spi->controller_state;
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs *cs = spi->controller_state;
./spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
./spi-omap2-mcspi.c:	struct spi_master *master = spi->master;
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs *cs = spi->controller_state;
./spi-omap2-mcspi.c:		mcspi->fifo_depth = fifo_depth;
./spi-omap2-mcspi.c:	mcspi->fifo_depth = 0;
./spi-omap2-mcspi.c:	struct spi_master	*spi_cntrl = mcspi->master;
./spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
./spi-omap2-mcspi.c:	struct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);
./spi-omap2-mcspi.c:	struct omap2_mcspi_dma *mcspi_dma = &mcspi->dma_channels[spi->chip_select];
./spi-omap2-mcspi.c:	struct omap2_mcspi *mcspi = spi_master_get_devdata(spi->master);
./spi-omap2-mcspi.c:	struct omap2_mcspi_dma *mcspi_dma = &mcspi->dma_channels[spi->chip_select];
./spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
./spi-omap2-mcspi.c:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
./spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
./spi-omap2-mcspi.c:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
./spi-omap2-mcspi.c:	if (mcspi->fifo_depth == 0)
./spi-omap2-mcspi.c:		if ((l & OMAP2_MCSPI_CHCONF_TURBO) && mcspi->fifo_depth == 0)
./spi-omap2-mcspi.c:	dma_unmap_single(mcspi->dev, xfer->rx_dma, count,
./spi-omap2-mcspi.c:	if (mcspi->fifo_depth > 0)
./spi-omap2-mcspi.c:			dev_err(&spi->dev, "DMA RX penultimate word empty\n");
./spi-omap2-mcspi.c:		dev_err(&spi->dev, "DMA RX last word empty\n");
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
./spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
./spi-omap2-mcspi.c:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
./spi-omap2-mcspi.c:	if (mcspi->fifo_depth > 0) {
./spi-omap2-mcspi.c:		if (count > mcspi->fifo_depth)
./spi-omap2-mcspi.c:			burst = mcspi->fifo_depth / es;
./spi-omap2-mcspi.c:		dma_unmap_single(mcspi->dev, xfer->tx_dma, xfer->len,
./spi-omap2-mcspi.c:		if (mcspi->fifo_depth > 0) {
./spi-omap2-mcspi.c:			irqstat_reg = mcspi->base + OMAP2_MCSPI_IRQSTATUS;
./spi-omap2-mcspi.c:				dev_err(&spi->dev, "EOW timed out\n");
./spi-omap2-mcspi.c:			mcspi_write_reg(mcspi->master, OMAP2_MCSPI_IRQSTATUS,
./spi-omap2-mcspi.c:			if (mcspi->fifo_depth > 0) {
./spi-omap2-mcspi.c:					dev_err(&spi->dev, "TXFFE timed out\n");
./spi-omap2-mcspi.c:					dev_err(&spi->dev, "TXS timed out\n");
./spi-omap2-mcspi.c:				dev_err(&spi->dev, "EOT timed out\n");
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
./spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
./spi-omap2-mcspi.c:					dev_err(&spi->dev, "TXS timed out\n");
./spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "write-%d %02x\n",
./spi-omap2-mcspi.c:					dev_err(&spi->dev, "RXS timed out\n");
./spi-omap2-mcspi.c:					dev_vdbg(&spi->dev, "read-%d %02x\n",
./spi-omap2-mcspi.c:						dev_err(&spi->dev,
./spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "read-%d %02x\n",
./spi-omap2-mcspi.c:					dev_err(&spi->dev, "TXS timed out\n");
./spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "write-%d %04x\n",
./spi-omap2-mcspi.c:					dev_err(&spi->dev, "RXS timed out\n");
./spi-omap2-mcspi.c:					dev_vdbg(&spi->dev, "read-%d %04x\n",
./spi-omap2-mcspi.c:						dev_err(&spi->dev,
./spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "read-%d %04x\n",
./spi-omap2-mcspi.c:					dev_err(&spi->dev, "TXS timed out\n");
./spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "write-%d %08x\n",
./spi-omap2-mcspi.c:					dev_err(&spi->dev, "RXS timed out\n");
./spi-omap2-mcspi.c:					dev_vdbg(&spi->dev, "read-%d %08x\n",
./spi-omap2-mcspi.c:						dev_err(&spi->dev,
./spi-omap2-mcspi.c:				dev_vdbg(&spi->dev, "read-%d %08x\n",
./spi-omap2-mcspi.c:			dev_err(&spi->dev, "TXS timed out\n");
./spi-omap2-mcspi.c:			dev_err(&spi->dev, "EOT timed out\n");
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs *cs = spi->controller_state;
./spi-omap2-mcspi.c:	u8 word_len = spi->bits_per_word;
./spi-omap2-mcspi.c:	u32 speed_hz = spi->max_speed_hz;
./spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
./spi-omap2-mcspi.c:	spi_cntrl = mcspi->master;
./spi-omap2-mcspi.c:	if (mcspi->pin_dir == MCSPI_PINDIR_D0_IN_D1_OUT) {
./spi-omap2-mcspi.c:	if (!(spi->mode & SPI_CS_HIGH))
./spi-omap2-mcspi.c:	if (spi->mode & SPI_CPOL)
./spi-omap2-mcspi.c:	if (spi->mode & SPI_CPHA)
./spi-omap2-mcspi.c:	cs->mode = spi->mode;
./spi-omap2-mcspi.c:	dev_dbg(&spi->dev, "setup: speed %d, sample %s edge, clk %s\n",
./spi-omap2-mcspi.c:			(spi->mode & SPI_CPHA) ? "trailing" : "leading",
./spi-omap2-mcspi.c:			(spi->mode & SPI_CPOL) ? "inverted" : "normal");
./spi-omap2-mcspi.c:	struct spi_master	*master = spi->master;
./spi-omap2-mcspi.c:	mcspi_dma = mcspi->dma_channels + spi->chip_select;
./spi-omap2-mcspi.c:	dev_warn(&spi->dev, "not using DMA for McSPI\n");
./spi-omap2-mcspi.c:	struct omap2_mcspi	*mcspi = spi_master_get_devdata(spi->master);
./spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
./spi-omap2-mcspi.c:	struct omap2_mcspi_cs	*cs = spi->controller_state;
./spi-omap2-mcspi.c:	mcspi_dma = &mcspi->dma_channels[spi->chip_select];
./spi-omap2-mcspi.c:		cs->base = mcspi->base + spi->chip_select * 0x14;
./spi-omap2-mcspi.c:		cs->phys = mcspi->phys + spi->chip_select * 0x14;
./spi-omap2-mcspi.c:		spi->controller_state = cs;
./spi-omap2-mcspi.c:	ret = pm_runtime_get_sync(mcspi->dev);
./spi-omap2-mcspi.c:	pm_runtime_mark_last_busy(mcspi->dev);
./spi-omap2-mcspi.c:	pm_runtime_put_autosuspend(mcspi->dev);
./spi-omap2-mcspi.c:	mcspi = spi_master_get_devdata(spi->master);
./spi-omap2-mcspi.c:	if (spi->controller_state) {
./spi-omap2-mcspi.c:		cs = spi->controller_state;
./spi-omap2-mcspi.c:	if (spi->chip_select < spi->master->num_chipselect) {
./spi-omap2-mcspi.c:		mcspi_dma = &mcspi->dma_channels[spi->chip_select];
./spi-omap2-mcspi.c:	master = spi->master;
./spi-omap2-mcspi.c:	mcspi_dma = mcspi->dma_channels + spi->chip_select;
./spi-omap2-mcspi.c:	cs = spi->controller_state;
./spi-omap2-mcspi.c:	cd = spi->controller_data;
./spi-omap2-mcspi.c:	 * The slave driver could have changed spi->mode in which case
./spi-omap2-mcspi.c:	if (spi->mode != cs->mode)
./spi-omap2-mcspi.c:		    (t->speed_hz != spi->max_speed_hz) ||
./spi-omap2-mcspi.c:		    (t->bits_per_word != spi->bits_per_word)) {
./spi-omap2-mcspi.c:			if (t->speed_hz == spi->max_speed_hz &&
./spi-omap2-mcspi.c:			    t->bits_per_word == spi->bits_per_word)
./spi-omap2-mcspi.c:			chconf = mcspi->ctx.modulctrl;
./spi-omap2-mcspi.c:			mcspi->ctx.modulctrl =
./spi-omap2-mcspi.c:		if (mcspi->fifo_depth > 0)
./spi-omap2-mcspi.c:		chconf = mcspi->ctx.modulctrl;
./spi-omap2-mcspi.c:		mcspi->ctx.modulctrl =
./spi-omap2-mcspi.c:	if (mcspi->fifo_depth > 0 && t)
./spi-omap2-mcspi.c:	mcspi_dma = mcspi->dma_channels + spi->chip_select;
./spi-omap2-mcspi.c:			dev_dbg(mcspi->dev, "transfer: %d Hz, %d %s%s, %d bpw\n",
./spi-omap2-mcspi.c:			t->tx_dma = dma_map_single(mcspi->dev, (void *) tx_buf,
./spi-omap2-mcspi.c:			if (dma_mapping_error(mcspi->dev, t->tx_dma)) {
./spi-omap2-mcspi.c:				dev_dbg(mcspi->dev, "dma %cX %d bytes error\n",
./spi-omap2-mcspi.c:			t->rx_dma = dma_map_single(mcspi->dev, rx_buf, t->len,
./spi-omap2-mcspi.c:			if (dma_mapping_error(mcspi->dev, t->rx_dma)) {
./spi-omap2-mcspi.c:				dev_dbg(mcspi->dev, "dma %cX %d bytes error\n",
./spi-omap2-mcspi.c:					dma_unmap_single(mcspi->dev, t->tx_dma,
./spi-omap2-mcspi.c:	struct spi_master	*master = mcspi->master;
./spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
./spi-omap2-mcspi.c:	ret = pm_runtime_get_sync(mcspi->dev);
./spi-omap2-mcspi.c:	pm_runtime_mark_last_busy(mcspi->dev);
./spi-omap2-mcspi.c:	pm_runtime_put_autosuspend(mcspi->dev);
./spi-omap2-mcspi.c:	/* the spi->mode bits understood by this driver: */
./spi-omap2-mcspi.c:	mcspi->master = master;
./spi-omap2-mcspi.c:		of_property_read_u32(node, "ti,spi-num-cs", &num_cs);
./spi-omap2-mcspi.c:			mcspi->pin_dir = MCSPI_PINDIR_D0_OUT_D1_IN;
./spi-omap2-mcspi.c:		mcspi->pin_dir = pdata->pin_dir;
./spi-omap2-mcspi.c:	mcspi->phys = r->start;
./spi-omap2-mcspi.c:	mcspi->base = devm_ioremap_resource(&pdev->dev, r);
./spi-omap2-mcspi.c:	if (IS_ERR(mcspi->base)) {
./spi-omap2-mcspi.c:		status = PTR_ERR(mcspi->base);
./spi-omap2-mcspi.c:	mcspi->dev = &pdev->dev;
./spi-omap2-mcspi.c:	INIT_LIST_HEAD(&mcspi->ctx.cs);
./spi-omap2-mcspi.c:	mcspi->dma_channels = devm_kcalloc(&pdev->dev, master->num_chipselect,
./spi-omap2-mcspi.c:	if (mcspi->dma_channels == NULL) {
./spi-omap2-mcspi.c:		char *dma_rx_ch_name = mcspi->dma_channels[i].dma_rx_ch_name;
./spi-omap2-mcspi.c:		char *dma_tx_ch_name = mcspi->dma_channels[i].dma_tx_ch_name;
./spi-omap2-mcspi.c:			mcspi->dma_channels[i].dma_rx_sync_dev =
./spi-omap2-mcspi.c:			mcspi->dma_channels[i].dma_tx_sync_dev =
./spi-omap2-mcspi.c:	pm_runtime_put_sync(mcspi->dev);
./spi-omap2-mcspi.c:	struct omap2_mcspi_regs	*ctx = &mcspi->ctx;
./spi-omap2-mcspi.c:	pm_runtime_get_sync(mcspi->dev);
./spi-omap2-mcspi.c:	pm_runtime_mark_last_busy(mcspi->dev);
./spi-omap2-mcspi.c:	pm_runtime_put_autosuspend(mcspi->dev);
./spi-lm70llp.c: * Also see Documentation/spi/spi-lm70llp.  The SPI<->parport code here is
./spi-lm70llp.c: * (heavily) based on spi-butterfly by David Brownell.
./spi-lm70llp.c:#define DRVNAME		"spi-lm70llp"
./spi-lm70llp.c:	return spi->controller_data;
./spi-lm70llp.c:#include "spi-bitbang-txrx.h"
./spi-mxs.c: * Based on spi-stmp.c, which is:
./spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
./spi-mxs.c:	if (hz != spi->sck) {
./spi-mxs.c:		spi->sck = hz;
./spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
./spi-mxs.c:	complete(&spi->c);
./spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
./spi-mxs.c:	reinit_completion(&spi->c);
./spi-mxs.c:	if (!wait_for_completion_timeout(&spi->c,
./spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
./spi-mxs.c:	struct mxs_ssp *ssp = &spi->ssp;
./spi-mxs.c:	writel(mxs_spi_cs_to_reg(m->spi->chip_select),
./spi-mxs.c:	ssp = &spi->ssp;
./spi-mxs.c:	init_completion(&spi->c);
./spi-mxs.c:	ssp = &spi->ssp;
./spi-bfin-sport.c:	struct bfin_sport_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
./spi-bfin-sport.c:	dev_dbg(&spi->dev, "adding an msg in transfer()\n");
./spi-bfin-sport.c:		chip_info = spi->controller_data;
./spi-bfin-sport.c:				dev_err(&spi->dev, "don't set ctl_reg/enable_dma fields\n");
./spi-bfin-sport.c:	if (spi->mode & SPI_CPHA)
./spi-bfin-sport.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-bfin-sport.c:	chip->baud = bfin_sport_hz_to_spi_baud(spi->max_speed_hz);
./spi-bfin-sport.c:	chip->cs_gpio = spi->chip_select;
./spi-bfin-sport.c:	ret = gpio_request(chip->cs_gpio, spi->modalias);
./spi-bfin-sport.c:	dev_dbg(&spi->dev, "setup spi chip %s, width is %d\n",
./spi-bfin-sport.c:			spi->modalias, spi->bits_per_word);
./spi-bfin-sport.c:	dev_dbg(&spi->dev, "ctl_reg is 0x%x, GPIO is %i\n",
./spi-bfin-sport.c:			chip->ctl_reg, spi->chip_select);
./spi-falcon.c:	struct device *dev = &spi->dev;
./spi-falcon.c:	struct falcon_sflash *priv = spi_master_get_devdata(spi->master);
./spi-falcon.c:				priv->sfcmd = ((spi->chip_select
./spi-falcon.c:	if (spi->max_speed_hz >= CLOCK_100M) {
./spi-falcon.c:			if (CLOCK_50M / i <= spi->max_speed_hz)
./spi-xcomm.c:	unsigned long cs = spi->chip_select;
./spi-xcomm.c:	if (spi->mode & SPI_CPOL)
./spi-xcomm.c:	if (spi->mode & SPI_CPHA)
./spi-xcomm.c:	if (spi->mode & SPI_3WIRE)
./spi-xcomm.c:	{ "spi-xcomm" },
./spi-xcomm.c:		.name	= "spi-xcomm",
./.built-in.o.cmd:cmd_drivers/spi/built-in.o :=  arm-angstrom-linux-gnueabi-ld.bfd    -r -o drivers/spi/built-in.o drivers/spi/spi.o drivers/spi/spidev.o drivers/spi/spi-fsl-dspi.o 
./spi-davinci.c:#include <linux/platform_data/spi-davinci.h>
./spi-davinci.c:	if (dspi->rx) {
./spi-davinci.c:		u8 *rx = dspi->rx;
./spi-davinci.c:		dspi->rx = rx;
./spi-davinci.c:	if (dspi->rx) {
./spi-davinci.c:		u16 *rx = dspi->rx;
./spi-davinci.c:		dspi->rx = rx;
./spi-davinci.c:	if (dspi->tx) {
./spi-davinci.c:		const u8 *tx = dspi->tx;
./spi-davinci.c:		dspi->tx = tx;
./spi-davinci.c:	if (dspi->tx) {
./spi-davinci.c:		const u16 *tx = dspi->tx;
./spi-davinci.c:		dspi->tx = tx;
./spi-davinci.c:	struct davinci_spi_config *spicfg = spi->controller_data;
./spi-davinci.c:	u8 chip_sel = spi->chip_select;
./spi-davinci.c:	dspi = spi_master_get_devdata(spi->master);
./spi-davinci.c:	pdata = &dspi->pdata;
./spi-davinci.c:	if (spi->cs_gpio >= 0) {
./spi-davinci.c:		gpio = spi->cs_gpio;
./spi-davinci.c:			gpio_set_value(gpio, spi->mode & SPI_CS_HIGH);
./spi-davinci.c:			gpio_set_value(gpio, !(spi->mode & SPI_CS_HIGH));
./spi-davinci.c:	iowrite16(spidat1, dspi->base + SPIDAT1 + 2);
./spi-davinci.c:	ret = DIV_ROUND_UP(clk_get_rate(dspi->clk), max_speed_hz);
./spi-davinci.c:	dspi = spi_master_get_devdata(spi->master);
./spi-davinci.c:	spicfg = spi->controller_data;
./spi-davinci.c:		bits_per_word = spi->bits_per_word;
./spi-davinci.c:		dspi->get_rx = davinci_spi_rx_buf_u8;
./spi-davinci.c:		dspi->get_tx = davinci_spi_tx_buf_u8;
./spi-davinci.c:		dspi->bytes_per_word[spi->chip_select] = 1;
./spi-davinci.c:		dspi->get_rx = davinci_spi_rx_buf_u16;
./spi-davinci.c:		dspi->get_tx = davinci_spi_tx_buf_u16;
./spi-davinci.c:		dspi->bytes_per_word[spi->chip_select] = 2;
./spi-davinci.c:		hz = spi->max_speed_hz;
./spi-davinci.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-davinci.c:	if (spi->mode & SPI_CPOL)
./spi-davinci.c:	if (!(spi->mode & SPI_CPHA))
./spi-davinci.c:	if (dspi->version == SPI_VERSION_2) {
./spi-davinci.c:		if (spi->mode & SPI_READY) {
./spi-davinci.c:		iowrite32(delay, dspi->base + SPIDELAY);
./spi-davinci.c:	iowrite32(spifmt, dspi->base + SPIFMT0);
./spi-davinci.c:	struct davinci_spi_config *spicfg = spi->controller_data;
./spi-davinci.c:	struct device_node *np = spi->dev.of_node;
./spi-davinci.c:		if (!of_property_read_u32(np, "ti,spi-wdelay", &prop))
./spi-davinci.c:		spi->controller_data = spicfg;
./spi-davinci.c:	struct spi_master *master = spi->master;
./spi-davinci.c:	struct device_node *np = spi->dev.of_node;
./spi-davinci.c:	dspi = spi_master_get_devdata(spi->master);
./spi-davinci.c:	pdata = &dspi->pdata;
./spi-davinci.c:	if (!(spi->mode & SPI_NO_CS)) {
./spi-davinci.c:		if (np && (master->cs_gpios != NULL) && (spi->cs_gpio >= 0)) {
./spi-davinci.c:				      spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
./spi-davinci.c:			   spi->chip_select < pdata->num_chipselect &&
./spi-davinci.c:			   pdata->chip_sel[spi->chip_select] != SPI_INTERN_CS) {
./spi-davinci.c:			spi->cs_gpio = pdata->chip_sel[spi->chip_select];
./spi-davinci.c:				      spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
./spi-davinci.c:			dev_err(&spi->dev, "GPIO %d setup failed (%d)\n",
./spi-davinci.c:				spi->cs_gpio, retval);
./spi-davinci.c:			set_io_bits(dspi->base + SPIPC0, 1 << spi->chip_select);
./spi-davinci.c:	if (spi->mode & SPI_READY)
./spi-davinci.c:		set_io_bits(dspi->base + SPIPC0, SPIPC0_SPIENA_MASK);
./spi-davinci.c:	if (spi->mode & SPI_LOOP)
./spi-davinci.c:		set_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);
./spi-davinci.c:		clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);
./spi-davinci.c:	struct davinci_spi_config *spicfg = spi->controller_data;
./spi-davinci.c:	spi->controller_data = NULL;
./spi-davinci.c:	if (spi->dev.of_node)
./spi-davinci.c:	struct device *sdev = dspi->bitbang.master->dev.parent;
./spi-davinci.c:	if (dspi->version == SPI_VERSION_2) {
./spi-davinci.c:	buf = ioread32(dspi->base + SPIBUF);
./spi-davinci.c:	if (dspi->rcount > 0 && !(buf & SPIBUF_RXEMPTY_MASK)) {
./spi-davinci.c:		dspi->get_rx(buf & 0xFFFF, dspi);
./spi-davinci.c:		dspi->rcount--;
./spi-davinci.c:	status = ioread32(dspi->base + SPIFLG);
./spi-davinci.c:	if (dspi->wcount > 0 && !(buf & SPIBUF_TXFULL_MASK)) {
./spi-davinci.c:		spidat1 = ioread32(dspi->base + SPIDAT1);
./spi-davinci.c:		dspi->wcount--;
./spi-davinci.c:		spidat1 |= 0xFFFF & dspi->get_tx(dspi);
./spi-davinci.c:		iowrite32(spidat1, dspi->base + SPIDAT1);
./spi-davinci.c:	dspi->rcount = 0;
./spi-davinci.c:	if (!dspi->wcount && !dspi->rcount)
./spi-davinci.c:		complete(&dspi->done);
./spi-davinci.c:	dspi->wcount = 0;
./spi-davinci.c:	if (!dspi->wcount && !dspi->rcount)
./spi-davinci.c:		complete(&dspi->done);
./spi-davinci.c:	dspi = spi_master_get_devdata(spi->master);
./spi-davinci.c:	pdata = &dspi->pdata;
./spi-davinci.c:	spicfg = (struct davinci_spi_config *)spi->controller_data;
./spi-davinci.c:	data_type = dspi->bytes_per_word[spi->chip_select];
./spi-davinci.c:	dspi->tx = t->tx_buf;
./spi-davinci.c:	dspi->rx = t->rx_buf;
./spi-davinci.c:	dspi->wcount = t->len / data_type;
./spi-davinci.c:	dspi->rcount = dspi->wcount;
./spi-davinci.c:	spidat1 = ioread32(dspi->base + SPIDAT1);
./spi-davinci.c:	clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);
./spi-davinci.c:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);
./spi-davinci.c:	reinit_completion(&dspi->done);
./spi-davinci.c:		set_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);
./spi-davinci.c:		dspi->wcount--;
./spi-davinci.c:		tx_data = dspi->get_tx(dspi);
./spi-davinci.c:		iowrite32(spidat1, dspi->base + SPIDAT1);
./spi-davinci.c:			.src_addr = (unsigned long)dspi->pbase + SPIBUF,
./spi-davinci.c:			.dst_addr = (unsigned long)dspi->pbase + SPIDAT1,
./spi-davinci.c:		dmaengine_slave_config(dspi->dma_rx, &dma_rx_conf);
./spi-davinci.c:		dmaengine_slave_config(dspi->dma_tx, &dma_tx_conf);
./spi-davinci.c:		t->rx_dma = dma_map_single(&spi->dev, buf,
./spi-davinci.c:		t->tx_dma = dma_map_single(&spi->dev, buf,
./spi-davinci.c:		rxdesc = dmaengine_prep_slave_sg(dspi->dma_rx,
./spi-davinci.c:		txdesc = dmaengine_prep_slave_sg(dspi->dma_tx,
./spi-davinci.c:			iowrite16(spidat1 >> 16, dspi->base + SPIDAT1 + 2);
./spi-davinci.c:		dma_async_issue_pending(dspi->dma_rx);
./spi-davinci.c:		dma_async_issue_pending(dspi->dma_tx);
./spi-davinci.c:		set_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);
./spi-davinci.c:		wait_for_completion_interruptible(&(dspi->done));
./spi-davinci.c:		while (dspi->rcount > 0 || dspi->wcount > 0) {
./spi-davinci.c:	clear_io_bits(dspi->base + SPIINT, SPIINT_MASKALL);
./spi-davinci.c:		clear_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);
./spi-davinci.c:		dma_unmap_single(&spi->dev, t->rx_dma,
./spi-davinci.c:		dma_unmap_single(&spi->dev, t->tx_dma,
./spi-davinci.c:	clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);
./spi-davinci.c:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);
./spi-davinci.c:							dev_name(&spi->dev));
./spi-davinci.c:	if (dspi->rcount != 0 || dspi->wcount != 0) {
./spi-davinci.c:		dev_err(&spi->dev, "SPI data transfer error\n");
./spi-davinci.c:	dma_unmap_single(&spi->dev, t->tx_dma, t->len, DMA_TO_DEVICE);
./spi-davinci.c:	dma_unmap_single(&spi->dev, t->rx_dma, t->len, DMA_FROM_DEVICE);
./spi-davinci.c:		clear_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);
./spi-davinci.c:	if ((!dspi->rcount && !dspi->wcount) || status)
./spi-davinci.c:		complete(&dspi->done);
./spi-davinci.c:	struct device *sdev = dspi->bitbang.master->dev.parent;
./spi-davinci.c:	dspi->dma_rx = dma_request_channel(mask, edma_filter_fn,
./spi-davinci.c:					   &dspi->dma_rx_chnum);
./spi-davinci.c:	if (!dspi->dma_rx) {
./spi-davinci.c:	dspi->dma_tx = dma_request_channel(mask, edma_filter_fn,
./spi-davinci.c:					   &dspi->dma_tx_chnum);
./spi-davinci.c:	if (!dspi->dma_tx) {
./spi-davinci.c:	dma_release_channel(dspi->dma_rx);
./spi-davinci.c:	pdata = &dspi->pdata;
./spi-davinci.c:	of_property_read_u32(node, "ti,davinci-spi-intr-line", &intr_line);
./spi-davinci.c:		dspi->pdata = *pdata;
./spi-davinci.c:	pdata = &dspi->pdata;
./spi-davinci.c:	dspi->bytes_per_word = devm_kzalloc(&pdev->dev,
./spi-davinci.c:					    sizeof(*dspi->bytes_per_word) *
./spi-davinci.c:	if (dspi->bytes_per_word == NULL) {
./spi-davinci.c:	dspi->pbase = r->start;
./spi-davinci.c:	dspi->base = devm_ioremap_resource(&pdev->dev, r);
./spi-davinci.c:	if (IS_ERR(dspi->base)) {
./spi-davinci.c:		ret = PTR_ERR(dspi->base);
./spi-davinci.c:	dspi->irq = platform_get_irq(pdev, 0);
./spi-davinci.c:	if (dspi->irq <= 0) {
./spi-davinci.c:	ret = devm_request_threaded_irq(&pdev->dev, dspi->irq, davinci_spi_irq,
./spi-davinci.c:	dspi->bitbang.master = master;
./spi-davinci.c:	dspi->clk = devm_clk_get(&pdev->dev, NULL);
./spi-davinci.c:	if (IS_ERR(dspi->clk)) {
./spi-davinci.c:	clk_prepare_enable(dspi->clk);
./spi-davinci.c:	dspi->bitbang.chipselect = davinci_spi_chipselect;
./spi-davinci.c:	dspi->bitbang.setup_transfer = davinci_spi_setup_transfer;
./spi-davinci.c:	dspi->version = pdata->version;
./spi-davinci.c:	dspi->bitbang.flags = SPI_NO_CS | SPI_LSB_FIRST | SPI_LOOP;
./spi-davinci.c:	if (dspi->version == SPI_VERSION_2)
./spi-davinci.c:		dspi->bitbang.flags |= SPI_READY;
./spi-davinci.c:	dspi->bitbang.txrx_bufs = davinci_spi_bufs;
./spi-davinci.c:		dspi->dma_rx_chnum = dma_rx_chan;
./spi-davinci.c:		dspi->dma_tx_chnum = dma_tx_chan;
./spi-davinci.c:	dspi->get_rx = davinci_spi_rx_buf_u8;
./spi-davinci.c:	dspi->get_tx = davinci_spi_tx_buf_u8;
./spi-davinci.c:	init_completion(&dspi->done);
./spi-davinci.c:	iowrite32(0, dspi->base + SPIGCR0);
./spi-davinci.c:	iowrite32(1, dspi->base + SPIGCR0);
./spi-davinci.c:	iowrite32(spipc0, dspi->base + SPIPC0);
./spi-davinci.c:		iowrite32(SPI_INTLVL_1, dspi->base + SPILVL);
./spi-davinci.c:		iowrite32(SPI_INTLVL_0, dspi->base + SPILVL);
./spi-davinci.c:	iowrite32(CS_DEFAULT, dspi->base + SPIDEF);
./spi-davinci.c:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_CLKMOD_MASK);
./spi-davinci.c:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_MASTER_MASK);
./spi-davinci.c:	set_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);
./spi-davinci.c:	ret = spi_bitbang_start(&dspi->bitbang);
./spi-davinci.c:	dev_info(&pdev->dev, "Controller at 0x%p\n", dspi->base);
./spi-davinci.c:	dma_release_channel(dspi->dma_rx);
./spi-davinci.c:	dma_release_channel(dspi->dma_tx);
./spi-davinci.c:	clk_disable_unprepare(dspi->clk);
./spi-davinci.c:	spi_bitbang_stop(&dspi->bitbang);
./spi-davinci.c:	clk_disable_unprepare(dspi->clk);
./spi-mpc512x-psc.c:	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
./spi-mpc512x-psc.c:	    ? t->speed_hz : spi->max_speed_hz;
./spi-mpc512x-psc.c:	    ? t->bits_per_word : spi->bits_per_word;
./spi-mpc512x-psc.c:	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
./spi-mpc512x-psc.c:	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
./spi-mpc512x-psc.c:	if (spi->mode & SPI_CPHA)
./spi-mpc512x-psc.c:	if (spi->mode & SPI_CPOL)
./spi-mpc512x-psc.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-mpc512x-psc.c:	if (mps->cs_control && gpio_is_valid(spi->cs_gpio))
./spi-mpc512x-psc.c:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 1 : 0);
./spi-mpc512x-psc.c:	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
./spi-mpc512x-psc.c:	if (mps->cs_control && gpio_is_valid(spi->cs_gpio))
./spi-mpc512x-psc.c:		mps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 0 : 1);
./spi-mpc512x-psc.c:	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
./spi-mpc512x-psc.c:			dev_warn(&spi->dev,
./spi-mpc512x-psc.c:	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
./spi-mpc512x-psc.c:	if (spi->bits_per_word % 8)
./spi-mpc512x-psc.c:		if (gpio_is_valid(spi->cs_gpio)) {
./spi-mpc512x-psc.c:			ret = gpio_request(spi->cs_gpio, dev_name(&spi->dev));
./spi-mpc512x-psc.c:				dev_err(&spi->dev, "can't get CS gpio: %d\n",
./spi-mpc512x-psc.c:			gpio_direction_output(spi->cs_gpio,
./spi-mpc512x-psc.c:					spi->mode & SPI_CS_HIGH ? 0 : 1);
./spi-mpc512x-psc.c:		spi->controller_state = cs;
./spi-mpc512x-psc.c:	cs->bits_per_word = spi->bits_per_word;
./spi-mpc512x-psc.c:	cs->speed_hz = spi->max_speed_hz;
./spi-mpc512x-psc.c:	if (gpio_is_valid(spi->cs_gpio))
./spi-mpc512x-psc.c:		gpio_free(spi->cs_gpio);
./spi-mpc512x-psc.c:	kfree(spi->controller_state);
./spi-mpc512x-psc.c:	gpio_set_value(spi->cs_gpio, onoff);
./spi-st-ssc4.c:	if (spi->bits_per_word > 8) {
./spi-st-ssc4.c:	} else if (spi->bits_per_word == 8 && !(t->len & 0x1)) {
./spi-st-ssc4.c:	spi_finalize_current_transfer(spi->master);
./spi-st-ssc4.c:	int cs = spi->cs_gpio;
./spi-st-ssc4.c:		devm_gpio_free(&spi->dev, cs);
./spi-st-ssc4.c:/* the spi->mode bits understood by this driver: */
./spi-st-ssc4.c:	struct spi_st *spi_st = spi_master_get_devdata(spi->master);
./spi-st-ssc4.c:	u32 hz = spi->max_speed_hz;
./spi-st-ssc4.c:	int cs = spi->cs_gpio;
./spi-st-ssc4.c:		dev_err(&spi->dev, "max_speed_hz unspecified\n");
./spi-st-ssc4.c:		dev_err(&spi->dev, "%d is not a valid gpio\n", cs);
./spi-st-ssc4.c:	if (devm_gpio_request(&spi->dev, cs, dev_name(&spi->dev))) {
./spi-st-ssc4.c:		dev_err(&spi->dev, "could not request gpio:%d\n", cs);
./spi-st-ssc4.c:	ret = gpio_direction_output(cs, spi->mode & SPI_CS_HIGH);
./spi-st-ssc4.c:		dev_err(&spi->dev,
./spi-st-ssc4.c:	dev_dbg(&spi->dev,
./spi-st-ssc4.c:	 if (spi->mode & SPI_CPOL)
./spi-st-ssc4.c:	 if (spi->mode & SPI_CPHA)
./spi-st-ssc4.c:	 if ((spi->mode & SPI_LSB_FIRST) == 0)
./spi-st-ssc4.c:	 if (spi->mode & SPI_LOOP)
./spi-st-ssc4.c:	 var |= (spi->bits_per_word - 1);
./spi-st-ssc4.c:		.name = "spi-st",
./spi-tegra114.c:	return readl(tspi->base + reg);
./spi-tegra114.c:	writel(val, tspi->base + reg);
./spi-tegra114.c:		readl(tspi->base + SPI_COMMAND1);
./spi-tegra114.c:	unsigned remain_len = t->len - tspi->cur_pos;
./spi-tegra114.c:	tspi->bytes_per_word = DIV_ROUND_UP(bits_per_word, 8);
./spi-tegra114.c:		tspi->is_packed = 1;
./spi-tegra114.c:		tspi->words_per_32bit = 32/bits_per_word;
./spi-tegra114.c:		tspi->is_packed = 0;
./spi-tegra114.c:		tspi->words_per_32bit = 1;
./spi-tegra114.c:	if (tspi->is_packed) {
./spi-tegra114.c:		max_len = min(remain_len, tspi->max_buf_size);
./spi-tegra114.c:		tspi->curr_dma_words = max_len/tspi->bytes_per_word;
./spi-tegra114.c:		max_word = (remain_len - 1) / tspi->bytes_per_word + 1;
./spi-tegra114.c:		max_word = min(max_word, tspi->max_buf_size/4);
./spi-tegra114.c:		tspi->curr_dma_words = max_word;
./spi-tegra114.c:	u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
./spi-tegra114.c:	if (tspi->is_packed) {
./spi-tegra114.c:		fifo_words_left = tx_empty_count * tspi->words_per_32bit;
./spi-tegra114.c:		written_words = min(fifo_words_left, tspi->curr_dma_words);
./spi-tegra114.c:		nbytes = written_words * tspi->bytes_per_word;
./spi-tegra114.c:		max_n_32bit = min(tspi->curr_dma_words,  tx_empty_count);
./spi-tegra114.c:		nbytes = written_words * tspi->bytes_per_word;
./spi-tegra114.c:			for (i = 0; nbytes && (i < tspi->bytes_per_word);
./spi-tegra114.c:	tspi->cur_tx_pos += written_words * tspi->bytes_per_word;
./spi-tegra114.c:	u8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_rx_pos;
./spi-tegra114.c:	if (tspi->is_packed) {
./spi-tegra114.c:		len = tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra114.c:		tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra114.c:		read_words += tspi->curr_dma_words;
./spi-tegra114.c:			for (i = 0; (i < tspi->bytes_per_word); i++)
./spi-tegra114.c:		tspi->cur_rx_pos += rx_full_count * tspi->bytes_per_word;
./spi-tegra114.c:	dma_sync_single_for_cpu(tspi->dev, tspi->tx_dma_phys,
./spi-tegra114.c:				tspi->dma_buf_size, DMA_TO_DEVICE);
./spi-tegra114.c:	if (tspi->is_packed) {
./spi-tegra114.c:		unsigned len = tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra114.c:		memcpy(tspi->tx_dma_buf, t->tx_buf + tspi->cur_pos, len);
./spi-tegra114.c:		u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
./spi-tegra114.c:		unsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra114.c:		for (count = 0; count < tspi->curr_dma_words; count++) {
./spi-tegra114.c:			for (i = 0; consume && (i < tspi->bytes_per_word);
./spi-tegra114.c:			tspi->tx_dma_buf[count] = x;
./spi-tegra114.c:	tspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra114.c:	dma_sync_single_for_device(tspi->dev, tspi->tx_dma_phys,
./spi-tegra114.c:				tspi->dma_buf_size, DMA_TO_DEVICE);
./spi-tegra114.c:	dma_sync_single_for_cpu(tspi->dev, tspi->rx_dma_phys,
./spi-tegra114.c:		tspi->dma_buf_size, DMA_FROM_DEVICE);
./spi-tegra114.c:	if (tspi->is_packed) {
./spi-tegra114.c:		unsigned len = tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra114.c:		memcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_dma_buf, len);
./spi-tegra114.c:		unsigned char *rx_buf = t->rx_buf + tspi->cur_rx_pos;
./spi-tegra114.c:		for (count = 0; count < tspi->curr_dma_words; count++) {
./spi-tegra114.c:			u32 x = tspi->rx_dma_buf[count] & rx_mask;
./spi-tegra114.c:			for (i = 0; (i < tspi->bytes_per_word); i++)
./spi-tegra114.c:	tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra114.c:	dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
./spi-tegra114.c:		tspi->dma_buf_size, DMA_FROM_DEVICE);
./spi-tegra114.c:	reinit_completion(&tspi->tx_dma_complete);
./spi-tegra114.c:	tspi->tx_dma_desc = dmaengine_prep_slave_single(tspi->tx_dma_chan,
./spi-tegra114.c:				tspi->tx_dma_phys, len, DMA_MEM_TO_DEV,
./spi-tegra114.c:	if (!tspi->tx_dma_desc) {
./spi-tegra114.c:		dev_err(tspi->dev, "Not able to get desc for Tx\n");
./spi-tegra114.c:	tspi->tx_dma_desc->callback = tegra_spi_dma_complete;
./spi-tegra114.c:	tspi->tx_dma_desc->callback_param = &tspi->tx_dma_complete;
./spi-tegra114.c:	dmaengine_submit(tspi->tx_dma_desc);
./spi-tegra114.c:	dma_async_issue_pending(tspi->tx_dma_chan);
./spi-tegra114.c:	reinit_completion(&tspi->rx_dma_complete);
./spi-tegra114.c:	tspi->rx_dma_desc = dmaengine_prep_slave_single(tspi->rx_dma_chan,
./spi-tegra114.c:				tspi->rx_dma_phys, len, DMA_DEV_TO_MEM,
./spi-tegra114.c:	if (!tspi->rx_dma_desc) {
./spi-tegra114.c:		dev_err(tspi->dev, "Not able to get desc for Rx\n");
./spi-tegra114.c:	tspi->rx_dma_desc->callback = tegra_spi_dma_complete;
./spi-tegra114.c:	tspi->rx_dma_desc->callback_param = &tspi->rx_dma_complete;
./spi-tegra114.c:	dmaengine_submit(tspi->rx_dma_desc);
./spi-tegra114.c:	dma_async_issue_pending(tspi->rx_dma_chan);
./spi-tegra114.c:		dev_err(tspi->dev, "Rx/Tx fifo are not empty status 0x%08x\n",
./spi-tegra114.c:	val = SPI_DMA_BLK_SET(tspi->curr_dma_words - 1);
./spi-tegra114.c:	if (tspi->is_packed)
./spi-tegra114.c:		len = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,
./spi-tegra114.c:		len = tspi->curr_dma_words * 4;
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX)
./spi-tegra114.c:	tspi->dma_control_reg = val;
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX) {
./spi-tegra114.c:			dev_err(tspi->dev,
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX) {
./spi-tegra114.c:		dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
./spi-tegra114.c:				tspi->dma_buf_size, DMA_FROM_DEVICE);
./spi-tegra114.c:			dev_err(tspi->dev,
./spi-tegra114.c:			if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra114.c:				dmaengine_terminate_all(tspi->tx_dma_chan);
./spi-tegra114.c:	tspi->is_curr_dma_xfer = true;
./spi-tegra114.c:	tspi->dma_control_reg = val;
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra114.c:		cur_words = tspi->curr_dma_words;
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX)
./spi-tegra114.c:	tspi->dma_control_reg = val;
./spi-tegra114.c:	tspi->is_curr_dma_xfer = false;
./spi-tegra114.c:	dma_chan = dma_request_slave_channel_reason(tspi->dev,
./spi-tegra114.c:			dev_err(tspi->dev,
./spi-tegra114.c:	dma_buf = dma_alloc_coherent(tspi->dev, tspi->dma_buf_size,
./spi-tegra114.c:		dev_err(tspi->dev, " Not able to allocate the dma buffer\n");
./spi-tegra114.c:		dma_sconfig.src_addr = tspi->phys + SPI_RX_FIFO;
./spi-tegra114.c:		dma_sconfig.dst_addr = tspi->phys + SPI_TX_FIFO;
./spi-tegra114.c:		tspi->rx_dma_chan = dma_chan;
./spi-tegra114.c:		tspi->rx_dma_buf = dma_buf;
./spi-tegra114.c:		tspi->rx_dma_phys = dma_phys;
./spi-tegra114.c:		tspi->tx_dma_chan = dma_chan;
./spi-tegra114.c:		tspi->tx_dma_buf = dma_buf;
./spi-tegra114.c:		tspi->tx_dma_phys = dma_phys;
./spi-tegra114.c:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
./spi-tegra114.c:		dma_buf = tspi->rx_dma_buf;
./spi-tegra114.c:		dma_chan = tspi->rx_dma_chan;
./spi-tegra114.c:		dma_phys = tspi->rx_dma_phys;
./spi-tegra114.c:		tspi->rx_dma_chan = NULL;
./spi-tegra114.c:		tspi->rx_dma_buf = NULL;
./spi-tegra114.c:		dma_buf = tspi->tx_dma_buf;
./spi-tegra114.c:		dma_chan = tspi->tx_dma_chan;
./spi-tegra114.c:		dma_phys = tspi->tx_dma_phys;
./spi-tegra114.c:		tspi->tx_dma_buf = NULL;
./spi-tegra114.c:		tspi->tx_dma_chan = NULL;
./spi-tegra114.c:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
./spi-tegra114.c:	struct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);
./spi-tegra114.c:	if (speed != tspi->cur_speed) {
./spi-tegra114.c:		clk_set_rate(tspi->clk, speed);
./spi-tegra114.c:		tspi->cur_speed = speed;
./spi-tegra114.c:	tspi->cur_spi = spi;
./spi-tegra114.c:	tspi->cur_pos = 0;
./spi-tegra114.c:	tspi->cur_rx_pos = 0;
./spi-tegra114.c:	tspi->cur_tx_pos = 0;
./spi-tegra114.c:	tspi->curr_xfer = t;
./spi-tegra114.c:		command1 = tspi->def_command1_reg;
./spi-tegra114.c:		req_mode = spi->mode & 0x3;
./spi-tegra114.c:		if (tspi->cs_control) {
./spi-tegra114.c:			if (tspi->cs_control != spi)
./spi-tegra114.c:			tspi->cs_control = NULL;
./spi-tegra114.c:		if (spi->mode & SPI_CS_HIGH)
./spi-tegra114.c:		command1 = tspi->command1_reg;
./spi-tegra114.c:	struct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);
./spi-tegra114.c:	if (tspi->is_packed)
./spi-tegra114.c:	tspi->cur_direction = 0;
./spi-tegra114.c:		tspi->cur_direction |= DATA_DIR_RX;
./spi-tegra114.c:		tspi->cur_direction |= DATA_DIR_TX;
./spi-tegra114.c:	command1 |= SPI_CS_SEL(spi->chip_select);
./spi-tegra114.c:	tspi->command1_reg = command1;
./spi-tegra114.c:	dev_dbg(tspi->dev, "The def 0x%x and written 0x%x\n",
./spi-tegra114.c:		tspi->def_command1_reg, (unsigned)command1);
./spi-tegra114.c:	struct tegra_spi_data *tspi = spi_master_get_devdata(spi->master);
./spi-tegra114.c:	dev_dbg(&spi->dev, "setup %d bpw, %scpol, %scpha, %dHz\n",
./spi-tegra114.c:		spi->bits_per_word,
./spi-tegra114.c:		spi->mode & SPI_CPOL ? "" : "~",
./spi-tegra114.c:		spi->mode & SPI_CPHA ? "" : "~",
./spi-tegra114.c:		spi->max_speed_hz);
./spi-tegra114.c:	ret = pm_runtime_get_sync(tspi->dev);
./spi-tegra114.c:		dev_err(tspi->dev, "pm runtime failed, e = %d\n", ret);
./spi-tegra114.c:	spin_lock_irqsave(&tspi->lock, flags);
./spi-tegra114.c:	val = tspi->def_command1_reg;
./spi-tegra114.c:	if (spi->mode & SPI_CS_HIGH)
./spi-tegra114.c:		val &= ~SPI_CS_POL_INACTIVE(spi->chip_select);
./spi-tegra114.c:		val |= SPI_CS_POL_INACTIVE(spi->chip_select);
./spi-tegra114.c:	tspi->def_command1_reg = val;
./spi-tegra114.c:	tegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);
./spi-tegra114.c:	spin_unlock_irqrestore(&tspi->lock, flags);
./spi-tegra114.c:	pm_runtime_put(tspi->dev);
./spi-tegra114.c:		reinit_completion(&tspi->xfer_completion);
./spi-tegra114.c:			dev_err(tspi->dev,
./spi-tegra114.c:		ret = wait_for_completion_timeout(&tspi->xfer_completion,
./spi-tegra114.c:			dev_err(tspi->dev,
./spi-tegra114.c:		if (tspi->tx_status ||  tspi->rx_status) {
./spi-tegra114.c:			dev_err(tspi->dev, "Error in Transfer\n");
./spi-tegra114.c:			tegra_spi_writel(tspi, tspi->def_command1_reg,
./spi-tegra114.c:				tspi->cs_control = spi;
./spi-tegra114.c:				tegra_spi_writel(tspi, tspi->def_command1_reg,
./spi-tegra114.c:			tegra_spi_writel(tspi, tspi->def_command1_reg,
./spi-tegra114.c:	struct spi_transfer *t = tspi->curr_xfer;
./spi-tegra114.c:	spin_lock_irqsave(&tspi->lock, flags);
./spi-tegra114.c:	if (tspi->tx_status ||  tspi->rx_status) {
./spi-tegra114.c:		dev_err(tspi->dev, "CpuXfer ERROR bit set 0x%x\n",
./spi-tegra114.c:			tspi->status_reg);
./spi-tegra114.c:		dev_err(tspi->dev, "CpuXfer 0x%08x:0x%08x\n",
./spi-tegra114.c:			tspi->command1_reg, tspi->dma_control_reg);
./spi-tegra114.c:		reset_control_assert(tspi->rst);
./spi-tegra114.c:		reset_control_deassert(tspi->rst);
./spi-tegra114.c:		complete(&tspi->xfer_completion);
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX)
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra114.c:		tspi->cur_pos = tspi->cur_tx_pos;
./spi-tegra114.c:		tspi->cur_pos = tspi->cur_rx_pos;
./spi-tegra114.c:	if (tspi->cur_pos == t->len) {
./spi-tegra114.c:		complete(&tspi->xfer_completion);
./spi-tegra114.c:	tegra_spi_calculate_curr_xfer_param(tspi->cur_spi, tspi, t);
./spi-tegra114.c:	spin_unlock_irqrestore(&tspi->lock, flags);
./spi-tegra114.c:	struct spi_transfer *t = tspi->curr_xfer;
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX) {
./spi-tegra114.c:		if (tspi->tx_status) {
./spi-tegra114.c:			dmaengine_terminate_all(tspi->tx_dma_chan);
./spi-tegra114.c:				&tspi->tx_dma_complete, SPI_DMA_TIMEOUT);
./spi-tegra114.c:				dmaengine_terminate_all(tspi->tx_dma_chan);
./spi-tegra114.c:				dev_err(tspi->dev, "TxDma Xfer failed\n");
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX) {
./spi-tegra114.c:		if (tspi->rx_status) {
./spi-tegra114.c:			dmaengine_terminate_all(tspi->rx_dma_chan);
./spi-tegra114.c:				&tspi->rx_dma_complete, SPI_DMA_TIMEOUT);
./spi-tegra114.c:				dmaengine_terminate_all(tspi->rx_dma_chan);
./spi-tegra114.c:				dev_err(tspi->dev, "RxDma Xfer failed\n");
./spi-tegra114.c:	spin_lock_irqsave(&tspi->lock, flags);
./spi-tegra114.c:		dev_err(tspi->dev, "DmaXfer: ERROR bit set 0x%x\n",
./spi-tegra114.c:			tspi->status_reg);
./spi-tegra114.c:		dev_err(tspi->dev, "DmaXfer 0x%08x:0x%08x\n",
./spi-tegra114.c:			tspi->command1_reg, tspi->dma_control_reg);
./spi-tegra114.c:		reset_control_assert(tspi->rst);
./spi-tegra114.c:		reset_control_deassert(tspi->rst);
./spi-tegra114.c:		complete(&tspi->xfer_completion);
./spi-tegra114.c:		spin_unlock_irqrestore(&tspi->lock, flags);
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX)
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra114.c:		tspi->cur_pos = tspi->cur_tx_pos;
./spi-tegra114.c:		tspi->cur_pos = tspi->cur_rx_pos;
./spi-tegra114.c:	if (tspi->cur_pos == t->len) {
./spi-tegra114.c:		complete(&tspi->xfer_completion);
./spi-tegra114.c:	total_fifo_words = tegra_spi_calculate_curr_xfer_param(tspi->cur_spi,
./spi-tegra114.c:	spin_unlock_irqrestore(&tspi->lock, flags);
./spi-tegra114.c:	if (!tspi->is_curr_dma_xfer)
./spi-tegra114.c:	tspi->status_reg = tegra_spi_readl(tspi, SPI_FIFO_STATUS);
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra114.c:		tspi->tx_status = tspi->status_reg &
./spi-tegra114.c:	if (tspi->cur_direction & DATA_DIR_RX)
./spi-tegra114.c:		tspi->rx_status = tspi->status_reg &
./spi-tegra114.c:	if (of_property_read_u32(pdev->dev.of_node, "spi-max-frequency",
./spi-tegra114.c:	/* the spi->mode bits understood by this driver: */
./spi-tegra114.c:	tspi->master = master;
./spi-tegra114.c:	tspi->dev = &pdev->dev;
./spi-tegra114.c:	spin_lock_init(&tspi->lock);
./spi-tegra114.c:	tspi->base = devm_ioremap_resource(&pdev->dev, r);
./spi-tegra114.c:	if (IS_ERR(tspi->base)) {
./spi-tegra114.c:		ret = PTR_ERR(tspi->base);
./spi-tegra114.c:	tspi->phys = r->start;
./spi-tegra114.c:	tspi->irq = spi_irq;
./spi-tegra114.c:	ret = request_threaded_irq(tspi->irq, tegra_spi_isr,
./spi-tegra114.c:					tspi->irq);
./spi-tegra114.c:	tspi->clk = devm_clk_get(&pdev->dev, "spi");
./spi-tegra114.c:	if (IS_ERR(tspi->clk)) {
./spi-tegra114.c:		ret = PTR_ERR(tspi->clk);
./spi-tegra114.c:	tspi->rst = devm_reset_control_get(&pdev->dev, "spi");
./spi-tegra114.c:	if (IS_ERR(tspi->rst)) {
./spi-tegra114.c:		ret = PTR_ERR(tspi->rst);
./spi-tegra114.c:	tspi->max_buf_size = SPI_FIFO_DEPTH << 2;
./spi-tegra114.c:	tspi->dma_buf_size = DEFAULT_SPI_DMA_BUF_LEN;
./spi-tegra114.c:	tspi->max_buf_size = tspi->dma_buf_size;
./spi-tegra114.c:	init_completion(&tspi->tx_dma_complete);
./spi-tegra114.c:	init_completion(&tspi->rx_dma_complete);
./spi-tegra114.c:	init_completion(&tspi->xfer_completion);
./spi-tegra114.c:	tspi->def_command1_reg  = SPI_M_S;
./spi-tegra114.c:	tegra_spi_writel(tspi, tspi->def_command1_reg, SPI_COMMAND1);
./spi-tegra114.c:	free_irq(tspi->irq, tspi);
./spi-tegra114.c:	if (tspi->tx_dma_chan)
./spi-tegra114.c:	if (tspi->rx_dma_chan)
./spi-tegra114.c:	tegra_spi_writel(tspi, tspi->command1_reg, SPI_COMMAND1);
./spi-tegra114.c:	clk_disable_unprepare(tspi->clk);
./spi-tegra114.c:	ret = clk_prepare_enable(tspi->clk);
./spi-tegra114.c:		dev_err(tspi->dev, "clk_prepare failed: %d\n", ret);
./spi-tegra114.c:		.name		= "spi-tegra114",
./spi-tegra114.c:MODULE_ALIAS("platform:spi-tegra114");
./spi-xtensa-xtfpga.c:	__raw_writel(val, spi->regs + addr);
./spi-xtensa-xtfpga.c:	return __raw_readl(spi->regs + addr);
./spi-xtensa-xtfpga.c:	struct xtfpga_spi *xspi = spi_master_get_devdata(spi->master);
./spi-xtensa-xtfpga.c:	xspi->data = (xspi->data << bits) | (v & GENMASK(bits - 1, 0));
./spi-xtensa-xtfpga.c:	xspi->data_sz += bits;
./spi-xtensa-xtfpga.c:	if (xspi->data_sz >= 16) {
./spi-xtensa-xtfpga.c:				   xspi->data >> (xspi->data_sz - 16));
./spi-xtensa-xtfpga.c:		xspi->data_sz -= 16;
./spi-xtensa-xtfpga.c:	struct xtfpga_spi *xspi = spi_master_get_devdata(spi->master);
./spi-xtensa-xtfpga.c:	WARN_ON(xspi->data_sz != 0);
./spi-xtensa-xtfpga.c:	xspi->data_sz = 0;
./spi-xtensa-xtfpga.c:	xspi->bitbang.master = master;
./spi-xtensa-xtfpga.c:	xspi->bitbang.chipselect = xtfpga_spi_chipselect;
./spi-xtensa-xtfpga.c:	xspi->bitbang.txrx_word[SPI_MODE_0] = xtfpga_spi_txrx_word;
./spi-xtensa-xtfpga.c:	xspi->regs = devm_ioremap_resource(&pdev->dev, mem);
./spi-xtensa-xtfpga.c:	if (IS_ERR(xspi->regs)) {
./spi-xtensa-xtfpga.c:		ret = PTR_ERR(xspi->regs);
./spi-xtensa-xtfpga.c:	ret = spi_bitbang_start(&xspi->bitbang);
./spi-xtensa-xtfpga.c:	spi_bitbang_stop(&xspi->bitbang);
./spi-dw.c:#include "spi-dw.h"
./spi-dw.c:	struct dw_spi *dws = spi_master_get_devdata(spi->master);
./spi-dw.c:		dw_writel(dws, DW_SPI_SER, BIT(spi->chip_select));
./spi-dw.c:			| (spi->mode << SPI_MODE_OFFSET)
./spi-dw.c:	chip_info = spi->controller_data;
./spi-dw.c:	if (spi->bits_per_word == 8) {
./spi-dw.c:	} else if (spi->bits_per_word == 16) {
./spi-dw.c:	chip->bits_per_word = spi->bits_per_word;
./spi-dw.c:	if (!spi->max_speed_hz) {
./spi-dw.c:		dev_err(&spi->dev, "No max speed HZ parameter\n");
./spi-dw.c:			| (spi->mode  << SPI_MODE_OFFSET)
./spi-dw.c:	if (spi->mode & SPI_LOOP)
./spi-dw.c:	if (gpio_is_valid(spi->cs_gpio)) {
./spi-dw.c:		ret = gpio_direction_output(spi->cs_gpio,
./spi-dw.c:				!(spi->mode & SPI_CS_HIGH));
./spi-fsl-cpm.c:#include "spi-fsl-cpm.h"
./spi-fsl-cpm.c:#include "spi-fsl-lib.h"
./spi-fsl-cpm.c:#include "spi-fsl-spi.h"
./spi-fsl-cpm.c:	if (mspi->flags & SPI_QE) {
./spi-fsl-cpm.c:		qe_issue_cmd(QE_INIT_TX_RX, mspi->subblock,
./spi-fsl-cpm.c:		if (mspi->flags & SPI_CPM1) {
./spi-fsl-cpm.c:			out_be32(&mspi->pram->rstate, 0);
./spi-fsl-cpm.c:			out_be16(&mspi->pram->rbptr,
./spi-fsl-cpm.c:				 in_be16(&mspi->pram->rbase));
./spi-fsl-cpm.c:			out_be32(&mspi->pram->tstate, 0);
./spi-fsl-cpm.c:			out_be16(&mspi->pram->tbptr,
./spi-fsl-cpm.c:				 in_be16(&mspi->pram->tbase));
./spi-fsl-cpm.c:	struct cpm_buf_desc __iomem *tx_bd = mspi->tx_bd;
./spi-fsl-cpm.c:	struct cpm_buf_desc __iomem *rx_bd = mspi->rx_bd;
./spi-fsl-cpm.c:	unsigned int xfer_len = min(mspi->count, SPI_MRBLR);
./spi-fsl-cpm.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
./spi-fsl-cpm.c:	xfer_ofs = mspi->xfer_in_progress->len - mspi->count;
./spi-fsl-cpm.c:	if (mspi->rx_dma == mspi->dma_dummy_rx)
./spi-fsl-cpm.c:		out_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma);
./spi-fsl-cpm.c:		out_be32(&rx_bd->cbd_bufaddr, mspi->rx_dma + xfer_ofs);
./spi-fsl-cpm.c:	if (mspi->tx_dma == mspi->dma_dummy_tx)
./spi-fsl-cpm.c:		out_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma);
./spi-fsl-cpm.c:		out_be32(&tx_bd->cbd_bufaddr, mspi->tx_dma + xfer_ofs);
./spi-fsl-cpm.c:	struct device *dev = mspi->dev;
./spi-fsl-cpm.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
./spi-fsl-cpm.c:		mspi->map_tx_dma = 0;
./spi-fsl-cpm.c:		mspi->map_rx_dma = 0;
./spi-fsl-cpm.c:		mspi->map_tx_dma = 1;
./spi-fsl-cpm.c:		mspi->map_rx_dma = 1;
./spi-fsl-cpm.c:		mspi->tx_dma = mspi->dma_dummy_tx;
./spi-fsl-cpm.c:		mspi->map_tx_dma = 0;
./spi-fsl-cpm.c:		mspi->rx_dma = mspi->dma_dummy_rx;
./spi-fsl-cpm.c:		mspi->map_rx_dma = 0;
./spi-fsl-cpm.c:	if (mspi->map_tx_dma) {
./spi-fsl-cpm.c:		void *nonconst_tx = (void *)mspi->tx; /* shut up gcc */
./spi-fsl-cpm.c:		mspi->tx_dma = dma_map_single(dev, nonconst_tx, t->len,
./spi-fsl-cpm.c:		if (dma_mapping_error(dev, mspi->tx_dma)) {
./spi-fsl-cpm.c:		mspi->tx_dma = t->tx_dma;
./spi-fsl-cpm.c:	if (mspi->map_rx_dma) {
./spi-fsl-cpm.c:		mspi->rx_dma = dma_map_single(dev, mspi->rx, t->len,
./spi-fsl-cpm.c:		if (dma_mapping_error(dev, mspi->rx_dma)) {
./spi-fsl-cpm.c:		mspi->rx_dma = t->rx_dma;
./spi-fsl-cpm.c:	mspi->xfer_in_progress = t;
./spi-fsl-cpm.c:	mspi->count = t->len;
./spi-fsl-cpm.c:	if (mspi->map_tx_dma)
./spi-fsl-cpm.c:		dma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);
./spi-fsl-cpm.c:	struct device *dev = mspi->dev;
./spi-fsl-cpm.c:	struct spi_transfer *t = mspi->xfer_in_progress;
./spi-fsl-cpm.c:	if (mspi->map_tx_dma)
./spi-fsl-cpm.c:		dma_unmap_single(dev, mspi->tx_dma, t->len, DMA_TO_DEVICE);
./spi-fsl-cpm.c:	if (mspi->map_rx_dma)
./spi-fsl-cpm.c:		dma_unmap_single(dev, mspi->rx_dma, t->len, DMA_FROM_DEVICE);
./spi-fsl-cpm.c:	mspi->xfer_in_progress = NULL;
./spi-fsl-cpm.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
./spi-fsl-cpm.c:	dev_dbg(mspi->dev, "%s: bd datlen %d, count %d\n", __func__,
./spi-fsl-cpm.c:		in_be16(&mspi->rx_bd->cbd_datlen), mspi->count);
./spi-fsl-cpm.c:	len = in_be16(&mspi->rx_bd->cbd_datlen);
./spi-fsl-cpm.c:	if (len > mspi->count) {
./spi-fsl-cpm.c:		len = mspi->count;
./spi-fsl-cpm.c:	mspi->count -= len;
./spi-fsl-cpm.c:	if (mspi->count)
./spi-fsl-cpm.c:		complete(&mspi->done);
./spi-fsl-cpm.c:	struct device *dev = mspi->dev;
./spi-fsl-cpm.c:	if (mspi->flags & SPI_QE && iprop && size == sizeof(*iprop) * 4)
./spi-fsl-cpm.c:	if (mspi->flags & SPI_QE) {
./spi-fsl-cpm.c:		qe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, mspi->subblock,
./spi-fsl-cpm.c:	if (mspi->flags & SPI_CPM2) {
./spi-fsl-cpm.c:	struct device *dev = mspi->dev;
./spi-fsl-cpm.c:	if (!(mspi->flags & SPI_CPM_MODE))
./spi-fsl-cpm.c:	if (mspi->flags & SPI_QE) {
./spi-fsl-cpm.c:			mspi->subblock = *iprop;
./spi-fsl-cpm.c:		switch (mspi->subblock) {
./spi-fsl-cpm.c:			mspi->subblock = QE_CR_SUBBLOCK_SPI1;
./spi-fsl-cpm.c:			mspi->subblock = QE_CR_SUBBLOCK_SPI2;
./spi-fsl-cpm.c:	if (mspi->flags & SPI_CPM1) {
./spi-fsl-cpm.c:			mspi->pram = NULL;
./spi-fsl-cpm.c:			mspi->pram = pram;
./spi-fsl-cpm.c:			mspi->pram = NULL;
./spi-fsl-cpm.c:			mspi->pram = cpm_muram_addr(pram_ofs);
./spi-fsl-cpm.c:	if (mspi->pram == NULL) {
./spi-fsl-cpm.c:	bds_ofs = cpm_muram_alloc(sizeof(*mspi->tx_bd) +
./spi-fsl-cpm.c:				  sizeof(*mspi->rx_bd), 8);
./spi-fsl-cpm.c:	mspi->dma_dummy_tx = dma_map_single(dev, empty_zero_page, PAGE_SIZE,
./spi-fsl-cpm.c:	if (dma_mapping_error(dev, mspi->dma_dummy_tx)) {
./spi-fsl-cpm.c:	mspi->dma_dummy_rx = dma_map_single(dev, fsl_dummy_rx, SPI_MRBLR,
./spi-fsl-cpm.c:	if (dma_mapping_error(dev, mspi->dma_dummy_rx)) {
./spi-fsl-cpm.c:	mspi->tx_bd = cpm_muram_addr(bds_ofs);
./spi-fsl-cpm.c:	mspi->rx_bd = cpm_muram_addr(bds_ofs + sizeof(*mspi->tx_bd));
./spi-fsl-cpm.c:	out_be16(&mspi->pram->tbase, cpm_muram_offset(mspi->tx_bd));
./spi-fsl-cpm.c:	out_be16(&mspi->pram->rbase, cpm_muram_offset(mspi->rx_bd));
./spi-fsl-cpm.c:	out_8(&mspi->pram->tfcr, CPMFCR_EB | CPMFCR_GBL);
./spi-fsl-cpm.c:	out_8(&mspi->pram->rfcr, CPMFCR_EB | CPMFCR_GBL);
./spi-fsl-cpm.c:	out_be16(&mspi->pram->mrblr, SPI_MRBLR);
./spi-fsl-cpm.c:	out_be32(&mspi->pram->rstate, 0);
./spi-fsl-cpm.c:	out_be32(&mspi->pram->rdp, 0);
./spi-fsl-cpm.c:	out_be16(&mspi->pram->rbptr, 0);
./spi-fsl-cpm.c:	out_be16(&mspi->pram->rbc, 0);
./spi-fsl-cpm.c:	out_be32(&mspi->pram->rxtmp, 0);
./spi-fsl-cpm.c:	out_be32(&mspi->pram->tstate, 0);
./spi-fsl-cpm.c:	out_be32(&mspi->pram->tdp, 0);
./spi-fsl-cpm.c:	out_be16(&mspi->pram->tbptr, 0);
./spi-fsl-cpm.c:	out_be16(&mspi->pram->tbc, 0);
./spi-fsl-cpm.c:	out_be32(&mspi->pram->txtmp, 0);
./spi-fsl-cpm.c:	dma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);
./spi-fsl-cpm.c:	if (!(mspi->flags & SPI_CPM1))
./spi-fsl-cpm.c:		cpm_muram_free(cpm_muram_offset(mspi->pram));
./spi-fsl-cpm.c:	struct device *dev = mspi->dev;
./spi-fsl-cpm.c:	if (!(mspi->flags & SPI_CPM_MODE))
./spi-fsl-cpm.c:	dma_unmap_single(dev, mspi->dma_dummy_rx, SPI_MRBLR, DMA_FROM_DEVICE);
./spi-fsl-cpm.c:	dma_unmap_single(dev, mspi->dma_dummy_tx, PAGE_SIZE, DMA_TO_DEVICE);
./spi-fsl-cpm.c:	cpm_muram_free(cpm_muram_offset(mspi->tx_bd));
./spi-fsl-cpm.c:	cpm_muram_free(cpm_muram_offset(mspi->pram));
./spi-octeon.c:	mode = spi->mode;
./spi-octeon.c:	speed_hz = xfer->speed_hz ? : spi->max_speed_hz;
./spi-octeon.c:	if (spi->chip_select < 4)
./spi-octeon.c:		p->cs_enax |= 1ull << (12 + spi->chip_select);
./spi-octeon.c:		mpi_tx.s.csid = spi->chip_select;
./spi-octeon.c:	mpi_tx.s.csid = spi->chip_select;
./spi-octeon.c:		.name		= "spi-octeon",
./spi-tegra20-sflash.c:	struct tegra_sflash_data *tsd = spi_master_get_devdata(spi->master);
./spi-tegra20-sflash.c:		if (spi->mode & SPI_CPHA)
./spi-tegra20-sflash.c:		if (spi->mode & SPI_CPOL)
./spi-tegra20-sflash.c:		command |= SPI_CS0_EN << spi->chip_select;
./spi-tegra20-sflash.c:	/* the spi->mode bits understood by this driver: */
./spi-tegra20-sflash.c:	if (of_property_read_u32(tsd->dev->of_node, "spi-max-frequency",
./spi-tegra20-sflash.c:		.name		= "spi-tegra-sflash",
./spi-tegra20-sflash.c:MODULE_ALIAS("platform:spi-tegra-sflash");
Binary file ./spi-fsl-dspi.o matches
./spi-clps711x.c:#include <linux/platform_data/spi-clps711x.h>
./spi-clps711x.c:#define DRIVER_NAME	"spi-clps711x"
./spi-clps711x.c:	gpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
./spi-clps711x.c:				  (spi->mode & SPI_CPHA) ?
./spi-clps711x.c:	clk_set_rate(hw->spi_clk, xfer->speed_hz ? : spi->max_speed_hz);
./spi-altera.c:	if (spi->mode & SPI_CS_HIGH) {
./spi-altera.c:			writel(1 << spi->chip_select,
./spi-altera.c:			writel(1 << spi->chip_select,
./spi-altera.c:	{ .compatible = "ALTR,spi-1.0", },
./spi-altera.c:	{ .compatible = "altr,spi-1.0", },
./spi-sun4i.c:	return readl(sspi->base_addr + reg);
./spi-sun4i.c:	writel(value, sspi->base_addr + reg);
./spi-sun4i.c:		byte = readb(sspi->base_addr + SUN4I_RXDATA_REG);
./spi-sun4i.c:		if (sspi->rx_buf)
./spi-sun4i.c:			*sspi->rx_buf++ = byte;
./spi-sun4i.c:	if (len > sspi->len)
./spi-sun4i.c:		len = sspi->len;
./spi-sun4i.c:		byte = sspi->tx_buf ? *sspi->tx_buf++ : 0;
./spi-sun4i.c:		writeb(byte, sspi->base_addr + SUN4I_TXDATA_REG);
./spi-sun4i.c:		sspi->len--;
./spi-sun4i.c:	struct sun4i_spi *sspi = spi_master_get_devdata(spi->master);
./spi-sun4i.c:	reg |= SUN4I_CTL_CS(spi->chip_select);
./spi-sun4i.c:	if (spi->mode & SPI_CS_HIGH)
./spi-sun4i.c:	reinit_completion(&sspi->done);
./spi-sun4i.c:	sspi->tx_buf = tfr->tx_buf;
./spi-sun4i.c:	sspi->rx_buf = tfr->rx_buf;
./spi-sun4i.c:	sspi->len = tfr->len;
./spi-sun4i.c:	if (spi->mode & SPI_CPOL)
./spi-sun4i.c:	if (spi->mode & SPI_CPHA)
./spi-sun4i.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-sun4i.c:	if (sspi->rx_buf)
./spi-sun4i.c:	mclk_rate = clk_get_rate(sspi->mclk);
./spi-sun4i.c:	if (mclk_rate < (2 * spi->max_speed_hz)) {
./spi-sun4i.c:		clk_set_rate(sspi->mclk, 2 * spi->max_speed_hz);
./spi-sun4i.c:		mclk_rate = clk_get_rate(sspi->mclk);
./spi-sun4i.c:	div = mclk_rate / (2 * spi->max_speed_hz);
./spi-sun4i.c:		div = ilog2(mclk_rate) - ilog2(spi->max_speed_hz);
./spi-sun4i.c:	if (sspi->tx_buf)
./spi-sun4i.c:	timeout = wait_for_completion_timeout(&sspi->done,
./spi-sun4i.c:		complete(&sspi->done);
./spi-sun4i.c:	ret = clk_prepare_enable(sspi->hclk);
./spi-sun4i.c:	ret = clk_prepare_enable(sspi->mclk);
./spi-sun4i.c:	clk_disable_unprepare(sspi->hclk);
./spi-sun4i.c:	clk_disable_unprepare(sspi->mclk);
./spi-sun4i.c:	clk_disable_unprepare(sspi->hclk);
./spi-sun4i.c:	sspi->base_addr = devm_ioremap_resource(&pdev->dev, res);
./spi-sun4i.c:	if (IS_ERR(sspi->base_addr)) {
./spi-sun4i.c:		ret = PTR_ERR(sspi->base_addr);
./spi-sun4i.c:	sspi->master = master;
./spi-sun4i.c:	sspi->hclk = devm_clk_get(&pdev->dev, "ahb");
./spi-sun4i.c:	if (IS_ERR(sspi->hclk)) {
./spi-sun4i.c:		ret = PTR_ERR(sspi->hclk);
./spi-sun4i.c:	sspi->mclk = devm_clk_get(&pdev->dev, "mod");
./spi-sun4i.c:	if (IS_ERR(sspi->mclk)) {
./spi-sun4i.c:		ret = PTR_ERR(sspi->mclk);
./spi-sun4i.c:	init_completion(&sspi->done);
./spi-pxa2xx.c:#include "spi-pxa2xx.h"
./spi-pxa2xx.c:		dev_warn_ratelimited(&message->spi->dev,
./spi-pxa2xx.c:				dev_warn_ratelimited(&message->spi->dev,
./spi-pxa2xx.c:			dev_err(&spi->dev, "failed to request chip select GPIO%d\n",
./spi-pxa2xx.c:		chip->gpio_cs_inverted = spi->mode & SPI_CS_HIGH;
./spi-pxa2xx.c:	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
./spi-pxa2xx.c:			if (spi->chip_select > 4) {
./spi-pxa2xx.c:				dev_err(&spi->dev,
./spi-pxa2xx.c:			chip->frm = spi->chip_select;
./spi-pxa2xx.c:	chip_info = spi->controller_data;
./spi-pxa2xx.c:	} else if (ACPI_HANDLE(&spi->dev)) {
./spi-pxa2xx.c:						spi->bits_per_word,
./spi-pxa2xx.c:			dev_warn(&spi->dev,
./spi-pxa2xx.c:	clk_div = pxa2xx_ssp_get_clk_div(drv_data, chip, spi->max_speed_hz);
./spi-pxa2xx.c:	chip->speed_hz = spi->max_speed_hz;
./spi-pxa2xx.c:					   spi->bits_per_word);
./spi-pxa2xx.c:	chip->cr1 |= (((spi->mode & SPI_CPHA) != 0) ? SSCR1_SPH : 0)
./spi-pxa2xx.c:			| (((spi->mode & SPI_CPOL) != 0) ? SSCR1_SPO : 0);
./spi-pxa2xx.c:	if (spi->mode & SPI_LOOP)
./spi-pxa2xx.c:		dev_dbg(&spi->dev, "%ld Hz actual, %s\n",
./spi-pxa2xx.c:		dev_dbg(&spi->dev, "%ld Hz actual, %s\n",
./spi-pxa2xx.c:	if (spi->bits_per_word <= 8) {
./spi-pxa2xx.c:	} else if (spi->bits_per_word <= 16) {
./spi-pxa2xx.c:	} else if (spi->bits_per_word <= 32) {
./spi-pxa2xx.c:	chip->bits_per_word = spi->bits_per_word;
./spi-pxa2xx.c:	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
./spi-pxa2xx.c:	/* the spi->mode bits understood by this driver: */
./spi-au1550.c:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
./spi-au1550.c:	unsigned cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;
./spi-au1550.c:			hw->pdata->deactivate_cs(hw->pdata, spi->chip_select,
./spi-au1550.c:		au1550_spi_bits_handlers_set(hw, spi->bits_per_word);
./spi-au1550.c:		if (spi->mode & SPI_CPOL)
./spi-au1550.c:		if (spi->mode & SPI_CPHA)
./spi-au1550.c:		if (spi->mode & SPI_LSB_FIRST)
./spi-au1550.c:		if (hw->usedma && spi->bits_per_word <= 8)
./spi-au1550.c:		cfg |= PSC_SPICFG_SET_LEN(spi->bits_per_word);
./spi-au1550.c:		cfg |= au1550_spi_baudcfg(hw, spi->max_speed_hz);
./spi-au1550.c:			hw->pdata->activate_cs(hw->pdata, spi->chip_select,
./spi-au1550.c:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
./spi-au1550.c:	bpw = spi->bits_per_word;
./spi-au1550.c:	hz = spi->max_speed_hz;
./spi-au1550.c:	au1550_spi_bits_handlers_set(hw, spi->bits_per_word);
./spi-au1550.c:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
./spi-au1550.c:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
./spi-au1550.c:	struct au1550_spi *hw = spi_master_get_devdata(spi->master);
./spi-au1550.c:	/* the spi->mode bits understood by this driver: */
./spi-omap-100k.c:	struct omap1_spi100k_cs *cs = spi->controller_state;
./spi-omap-100k.c:				spi100k_write_data(spi->master, word_len, *tx++);
./spi-omap-100k.c:				*rx++ = spi100k_read_data(spi->master, word_len);
./spi-omap-100k.c:				spi100k_write_data(spi->master, word_len, *tx++);
./spi-omap-100k.c:				*rx++ = spi100k_read_data(spi->master, word_len);
./spi-omap-100k.c:				spi100k_write_data(spi->master, word_len, *tx);
./spi-omap-100k.c:				*rx = spi100k_read_data(spi->master, word_len);
./spi-omap-100k.c:	struct omap1_spi100k *spi100k = spi_master_get_devdata(spi->master);
./spi-omap-100k.c:	struct omap1_spi100k_cs *cs = spi->controller_state;
./spi-omap-100k.c:	u8 word_len = spi->bits_per_word;
./spi-omap-100k.c:	if (spi->bits_per_word > 32)
./spi-omap-100k.c:/* the spi->mode bits understood by this driver: */
./spi-omap-100k.c:	struct omap1_spi100k_cs *cs = spi->controller_state;
./spi-omap-100k.c:	spi100k = spi_master_get_devdata(spi->master);
./spi-omap-100k.c:		cs = devm_kzalloc(&spi->dev, sizeof(*cs), GFP_KERNEL);
./spi-omap-100k.c:		cs->base = spi100k->base + spi->chip_select * 0x14;
./spi-omap-100k.c:		spi->controller_state = cs;
./spi-omap-100k.c:	spi100k_open(spi->master);
./spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QMR);
./spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QDLYR);
./spi-coldfire-qspi.c:	return readw(mcfqspi->iobase + MCFQSPI_QDLYR);
./spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QWR);
./spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QIR);
./spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QAR);
./spi-coldfire-qspi.c:	writew(val, mcfqspi->iobase + MCFQSPI_QDR);
./spi-coldfire-qspi.c:	return readw(mcfqspi->iobase + MCFQSPI_QDR);
./spi-coldfire-qspi.c:	mcfqspi->cs_control->select(mcfqspi->cs_control, chip_select, cs_high);
./spi-coldfire-qspi.c:	mcfqspi->cs_control->deselect(mcfqspi->cs_control, chip_select, cs_high);
./spi-coldfire-qspi.c:	return (mcfqspi->cs_control->setup) ?
./spi-coldfire-qspi.c:		mcfqspi->cs_control->setup(mcfqspi->cs_control) : 0;
./spi-coldfire-qspi.c:	if (mcfqspi->cs_control->teardown)
./spi-coldfire-qspi.c:		mcfqspi->cs_control->teardown(mcfqspi->cs_control);
./spi-coldfire-qspi.c:	wake_up(&mcfqspi->waitq);
./spi-coldfire-qspi.c:			wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
./spi-coldfire-qspi.c:		wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
./spi-coldfire-qspi.c:	wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
./spi-coldfire-qspi.c:			wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
./spi-coldfire-qspi.c:		wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
./spi-coldfire-qspi.c:	wait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));
./spi-coldfire-qspi.c:	struct mcfqspi *mcfqspi = spi_master_get_devdata(spi->master);
./spi-coldfire-qspi.c:	bool cs_high = spi->mode & SPI_CS_HIGH;
./spi-coldfire-qspi.c:		mcfqspi_cs_select(mcfqspi, spi->chip_select, cs_high);
./spi-coldfire-qspi.c:		mcfqspi_cs_deselect(mcfqspi, spi->chip_select, cs_high);
./spi-coldfire-qspi.c:	if (spi->mode & SPI_CPHA)
./spi-coldfire-qspi.c:	if (spi->mode & SPI_CPOL)
./spi-coldfire-qspi.c:	mcfqspi_cs_deselect(spi_master_get_devdata(spi->master),
./spi-coldfire-qspi.c:			    spi->chip_select, spi->mode & SPI_CS_HIGH);
./spi-coldfire-qspi.c:	dev_dbg(&spi->dev,
./spi-coldfire-qspi.c:			spi->bits_per_word, spi->chip_select,
./spi-coldfire-qspi.c:			(MCFQSPI_BUSCLK / mcfqspi_qmr_baud(spi->max_speed_hz))
./spi-coldfire-qspi.c:	mcfqspi->iobase = devm_ioremap_resource(&pdev->dev, res);
./spi-coldfire-qspi.c:	if (IS_ERR(mcfqspi->iobase)) {
./spi-coldfire-qspi.c:		status = PTR_ERR(mcfqspi->iobase);
./spi-coldfire-qspi.c:	mcfqspi->irq = platform_get_irq(pdev, 0);
./spi-coldfire-qspi.c:	if (mcfqspi->irq < 0) {
./spi-coldfire-qspi.c:	status = devm_request_irq(&pdev->dev, mcfqspi->irq, mcfqspi_irq_handler,
./spi-coldfire-qspi.c:	mcfqspi->clk = devm_clk_get(&pdev->dev, "qspi_clk");
./spi-coldfire-qspi.c:	if (IS_ERR(mcfqspi->clk)) {
./spi-coldfire-qspi.c:		status = PTR_ERR(mcfqspi->clk);
./spi-coldfire-qspi.c:	clk_enable(mcfqspi->clk);
./spi-coldfire-qspi.c:	mcfqspi->cs_control = pdata->cs_control;
./spi-coldfire-qspi.c:	init_waitqueue_head(&mcfqspi->waitq);
./spi-coldfire-qspi.c:	clk_disable(mcfqspi->clk);
./spi-coldfire-qspi.c:	clk_disable(mcfqspi->clk);
./spi-coldfire-qspi.c:	clk_disable(mcfqspi->clk);
./spi-coldfire-qspi.c:	clk_enable(mcfqspi->clk);
./spi-coldfire-qspi.c:	clk_disable(mcfqspi->clk);
./spi-coldfire-qspi.c:	clk_enable(mcfqspi->clk);
./spi-sirf.c:	u8 *rx = sspi->rx;
./spi-sirf.c:	data = readl(sspi->base + SIRFSOC_SPI_RXFIFO_DATA);
./spi-sirf.c:		sspi->rx = rx;
./spi-sirf.c:	sspi->left_rx_word--;
./spi-sirf.c:	const u8 *tx = sspi->tx;
./spi-sirf.c:		sspi->tx = tx;
./spi-sirf.c:	writel(data, sspi->base + SIRFSOC_SPI_TXFIFO_DATA);
./spi-sirf.c:	sspi->left_tx_word--;
./spi-sirf.c:	u16 *rx = sspi->rx;
./spi-sirf.c:	data = readl(sspi->base + SIRFSOC_SPI_RXFIFO_DATA);
./spi-sirf.c:		sspi->rx = rx;
./spi-sirf.c:	sspi->left_rx_word--;
./spi-sirf.c:	const u16 *tx = sspi->tx;
./spi-sirf.c:		sspi->tx = tx;
./spi-sirf.c:	writel(data, sspi->base + SIRFSOC_SPI_TXFIFO_DATA);
./spi-sirf.c:	sspi->left_tx_word--;
./spi-sirf.c:	u32 *rx = sspi->rx;
./spi-sirf.c:	data = readl(sspi->base + SIRFSOC_SPI_RXFIFO_DATA);
./spi-sirf.c:		sspi->rx = rx;
./spi-sirf.c:	sspi->left_rx_word--;
./spi-sirf.c:	const u32 *tx = sspi->tx;
./spi-sirf.c:		sspi->tx = tx;
./spi-sirf.c:	writel(data, sspi->base + SIRFSOC_SPI_TXFIFO_DATA);
./spi-sirf.c:	sspi->left_tx_word--;
./spi-sirf.c:	u32 spi_stat = readl(sspi->base + SIRFSOC_SPI_INT_STATUS);
./spi-sirf.c:	if (sspi->tx_by_cmd && (spi_stat & SIRFSOC_SPI_FRM_END)) {
./spi-sirf.c:		complete(&sspi->tx_done);
./spi-sirf.c:		writel(0x0, sspi->base + SIRFSOC_SPI_INT_EN);
./spi-sirf.c:				sspi->base + SIRFSOC_SPI_INT_STATUS);
./spi-sirf.c:		complete(&sspi->tx_done);
./spi-sirf.c:		complete(&sspi->rx_done);
./spi-sirf.c:		writel(0x0, sspi->base + SIRFSOC_SPI_INT_EN);
./spi-sirf.c:				sspi->base + SIRFSOC_SPI_INT_STATUS);
./spi-sirf.c:		complete(&sspi->tx_done);
./spi-sirf.c:	while (!(readl(sspi->base + SIRFSOC_SPI_INT_STATUS) &
./spi-sirf.c:	complete(&sspi->rx_done);
./spi-sirf.c:	writel(0x0, sspi->base + SIRFSOC_SPI_INT_EN);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_INT_STATUS);
./spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:	memcpy(&cmd, sspi->tx, t->len);
./spi-sirf.c:	if (sspi->word_width == 1 && !(spi->mode & SPI_LSB_FIRST))
./spi-sirf.c:	if (sspi->word_width == 2 && t->len == 4 &&
./spi-sirf.c:			(!(spi->mode & SPI_LSB_FIRST)))
./spi-sirf.c:	writel(cmd, sspi->base + SIRFSOC_SPI_CMD);
./spi-sirf.c:		sspi->base + SIRFSOC_SPI_INT_EN);
./spi-sirf.c:		sspi->base + SIRFSOC_SPI_TX_RX_EN);
./spi-sirf.c:	if (wait_for_completion_timeout(&sspi->tx_done, timeout) == 0) {
./spi-sirf.c:		dev_err(&spi->dev, "cmd transfer timeout\n");
./spi-sirf.c:	sspi->left_rx_word -= t->len;
./spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_RXFIFO_OP);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_RXFIFO_OP);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:	writel(0, sspi->base + SIRFSOC_SPI_INT_EN);
./spi-sirf.c:	writel(SIRFSOC_SPI_INT_MASK_ALL, sspi->base + SIRFSOC_SPI_INT_STATUS);
./spi-sirf.c:	if (sspi->left_tx_word < SIRFSOC_SPI_DAT_FRM_LEN_MAX) {
./spi-sirf.c:		writel(readl(sspi->base + SIRFSOC_SPI_CTRL) |
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_CTRL);
./spi-sirf.c:		writel(sspi->left_tx_word - 1,
./spi-sirf.c:				sspi->base + SIRFSOC_SPI_TX_DMA_IO_LEN);
./spi-sirf.c:		writel(sspi->left_tx_word - 1,
./spi-sirf.c:				sspi->base + SIRFSOC_SPI_RX_DMA_IO_LEN);
./spi-sirf.c:		writel(readl(sspi->base + SIRFSOC_SPI_CTRL),
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_CTRL);
./spi-sirf.c:		writel(0, sspi->base + SIRFSOC_SPI_TX_DMA_IO_LEN);
./spi-sirf.c:		writel(0, sspi->base + SIRFSOC_SPI_RX_DMA_IO_LEN);
./spi-sirf.c:	sspi->dst_start = dma_map_single(&spi->dev, sspi->rx, t->len,
./spi-sirf.c:	rx_desc = dmaengine_prep_slave_single(sspi->rx_chan,
./spi-sirf.c:		sspi->dst_start, t->len, DMA_DEV_TO_MEM,
./spi-sirf.c:	rx_desc->callback_param = &sspi->rx_done;
./spi-sirf.c:	sspi->src_start = dma_map_single(&spi->dev, (void *)sspi->tx, t->len,
./spi-sirf.c:	tx_desc = dmaengine_prep_slave_single(sspi->tx_chan,
./spi-sirf.c:		sspi->src_start, t->len, DMA_MEM_TO_DEV,
./spi-sirf.c:	tx_desc->callback_param = &sspi->tx_done;
./spi-sirf.c:	dma_async_issue_pending(sspi->tx_chan);
./spi-sirf.c:	dma_async_issue_pending(sspi->rx_chan);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_TX_RX_EN);
./spi-sirf.c:	if (wait_for_completion_timeout(&sspi->rx_done, timeout) == 0) {
./spi-sirf.c:		dev_err(&spi->dev, "transfer timeout\n");
./spi-sirf.c:		dmaengine_terminate_all(sspi->rx_chan);
./spi-sirf.c:		sspi->left_rx_word = 0;
./spi-sirf.c:	if (wait_for_completion_timeout(&sspi->tx_done, timeout) == 0) {
./spi-sirf.c:		dev_err(&spi->dev, "transfer timeout\n");
./spi-sirf.c:		dmaengine_terminate_all(sspi->tx_chan);
./spi-sirf.c:	dma_unmap_single(&spi->dev, sspi->src_start, t->len, DMA_TO_DEVICE);
./spi-sirf.c:	dma_unmap_single(&spi->dev, sspi->dst_start, t->len, DMA_FROM_DEVICE);
./spi-sirf.c:	writel(0, sspi->base + SIRFSOC_SPI_RXFIFO_OP);
./spi-sirf.c:	writel(0, sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:	if (sspi->left_tx_word >= SIRFSOC_SPI_DAT_FRM_LEN_MAX)
./spi-sirf.c:		writel(0, sspi->base + SIRFSOC_SPI_TX_RX_EN);
./spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_RXFIFO_OP);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_RXFIFO_OP);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:		writel(0, sspi->base + SIRFSOC_SPI_INT_EN);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_INT_STATUS);
./spi-sirf.c:		writel(readl(sspi->base + SIRFSOC_SPI_CTRL) |
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_CTRL);
./spi-sirf.c:		writel(min(sspi->left_tx_word, (u32)(256 / sspi->word_width))
./spi-sirf.c:				- 1, sspi->base + SIRFSOC_SPI_TX_DMA_IO_LEN);
./spi-sirf.c:		writel(min(sspi->left_rx_word, (u32)(256 / sspi->word_width))
./spi-sirf.c:				- 1, sspi->base + SIRFSOC_SPI_RX_DMA_IO_LEN);
./spi-sirf.c:		while (!((readl(sspi->base + SIRFSOC_SPI_TXFIFO_STATUS)
./spi-sirf.c:			& SIRFSOC_SPI_FIFO_FULL)) && sspi->left_tx_word)
./spi-sirf.c:			sspi->tx_word(sspi);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_INT_EN);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_TX_RX_EN);
./spi-sirf.c:		if (!wait_for_completion_timeout(&sspi->tx_done, timeout) ||
./spi-sirf.c:			!wait_for_completion_timeout(&sspi->rx_done, timeout)) {
./spi-sirf.c:			dev_err(&spi->dev, "transfer timeout\n");
./spi-sirf.c:		while (!((readl(sspi->base + SIRFSOC_SPI_RXFIFO_STATUS)
./spi-sirf.c:			& SIRFSOC_SPI_FIFO_EMPTY)) && sspi->left_rx_word)
./spi-sirf.c:			sspi->rx_word(sspi);
./spi-sirf.c:		writel(0, sspi->base + SIRFSOC_SPI_RXFIFO_OP);
./spi-sirf.c:		writel(0, sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:	} while (sspi->left_tx_word != 0 || sspi->left_rx_word != 0);
./spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
./spi-sirf.c:	sspi->tx = t->tx_buf ? t->tx_buf : sspi->dummypage;
./spi-sirf.c:	sspi->rx = t->rx_buf ? t->rx_buf : sspi->dummypage;
./spi-sirf.c:	sspi->left_tx_word = sspi->left_rx_word = t->len / sspi->word_width;
./spi-sirf.c:	reinit_completion(&sspi->rx_done);
./spi-sirf.c:	reinit_completion(&sspi->tx_done);
./spi-sirf.c:	if (sspi->tx_by_cmd)
./spi-sirf.c:	return t->len - sspi->left_rx_word * sspi->word_width;
./spi-sirf.c:	struct sirfsoc_spi *sspi = spi_master_get_devdata(spi->master);
./spi-sirf.c:	if (sspi->hw_cs) {
./spi-sirf.c:		u32 regval = readl(sspi->base + SIRFSOC_SPI_CTRL);
./spi-sirf.c:			if (spi->mode & SPI_CS_HIGH)
./spi-sirf.c:			if (spi->mode & SPI_CS_HIGH)
./spi-sirf.c:		writel(regval, sspi->base + SIRFSOC_SPI_CTRL);
./spi-sirf.c:			gpio_direction_output(spi->cs_gpio,
./spi-sirf.c:					spi->mode & SPI_CS_HIGH ? 1 : 0);
./spi-sirf.c:			gpio_direction_output(spi->cs_gpio,
./spi-sirf.c:					spi->mode & SPI_CS_HIGH ? 0 : 1);
./spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
./spi-sirf.c:	bits_per_word = (t) ? t->bits_per_word : spi->bits_per_word;
./spi-sirf.c:	hz = t && t->speed_hz ? t->speed_hz : spi->max_speed_hz;
./spi-sirf.c:	regval = (sspi->ctrl_freq / (2 * hz)) - 1;
./spi-sirf.c:		dev_err(&spi->dev, "Speed %d not supported\n", hz);
./spi-sirf.c:		sspi->rx_word = spi_sirfsoc_rx_word_u8;
./spi-sirf.c:		sspi->tx_word = spi_sirfsoc_tx_word_u8;
./spi-sirf.c:		sspi->rx_word = spi_sirfsoc_rx_word_u16;
./spi-sirf.c:		sspi->tx_word = spi_sirfsoc_tx_word_u16;
./spi-sirf.c:		sspi->rx_word = spi_sirfsoc_rx_word_u32;
./spi-sirf.c:		sspi->tx_word = spi_sirfsoc_tx_word_u32;
./spi-sirf.c:	sspi->word_width = DIV_ROUND_UP(bits_per_word, 8);
./spi-sirf.c:					   (sspi->word_width >> 1);
./spi-sirf.c:					   (sspi->word_width >> 1);
./spi-sirf.c:	if (!(spi->mode & SPI_CS_HIGH))
./spi-sirf.c:	if (!(spi->mode & SPI_LSB_FIRST))
./spi-sirf.c:	if (spi->mode & SPI_CPOL)
./spi-sirf.c:	if (((spi->mode & SPI_CPOL) && (spi->mode & SPI_CPHA)) ||
./spi-sirf.c:	    (!(spi->mode & SPI_CPOL) && !(spi->mode & SPI_CPHA)))
./spi-sirf.c:		sspi->base + SIRFSOC_SPI_TXFIFO_LEVEL_CHK);
./spi-sirf.c:		sspi->base + SIRFSOC_SPI_RXFIFO_LEVEL_CHK);
./spi-sirf.c:	writel(txfifo_ctrl, sspi->base + SIRFSOC_SPI_TXFIFO_CTRL);
./spi-sirf.c:	writel(rxfifo_ctrl, sspi->base + SIRFSOC_SPI_RXFIFO_CTRL);
./spi-sirf.c:		sspi->tx_by_cmd = true;
./spi-sirf.c:		sspi->tx_by_cmd = false;
./spi-sirf.c:	writel(regval, sspi->base + SIRFSOC_SPI_CTRL);
./spi-sirf.c:		writel(0, sspi->base + SIRFSOC_SPI_TX_DMA_IO_CTRL);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_RX_DMA_IO_CTRL);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_TX_DMA_IO_CTRL);
./spi-sirf.c:			sspi->base + SIRFSOC_SPI_RX_DMA_IO_CTRL);
./spi-sirf.c:	sspi = spi_master_get_devdata(spi->master);
./spi-sirf.c:	if (spi->cs_gpio == -ENOENT)
./spi-sirf.c:		sspi->hw_cs = true;
./spi-sirf.c:		sspi->hw_cs = false;
./spi-sirf.c:	sspi->base = devm_ioremap_resource(&pdev->dev, mem_res);
./spi-sirf.c:	if (IS_ERR(sspi->base)) {
./spi-sirf.c:		ret = PTR_ERR(sspi->base);
./spi-sirf.c:	sspi->bitbang.master = master;
./spi-sirf.c:	sspi->bitbang.chipselect = spi_sirfsoc_chipselect;
./spi-sirf.c:	sspi->bitbang.setup_transfer = spi_sirfsoc_setup_transfer;
./spi-sirf.c:	sspi->bitbang.txrx_bufs = spi_sirfsoc_transfer;
./spi-sirf.c:	sspi->bitbang.master->setup = spi_sirfsoc_setup;
./spi-sirf.c:	sspi->bitbang.master->dev.of_node = pdev->dev.of_node;
./spi-sirf.c:	sspi->rx_chan = dma_request_slave_channel(&pdev->dev, "rx");
./spi-sirf.c:	if (!sspi->rx_chan) {
./spi-sirf.c:	sspi->tx_chan = dma_request_slave_channel(&pdev->dev, "tx");
./spi-sirf.c:	if (!sspi->tx_chan) {
./spi-sirf.c:	sspi->clk = clk_get(&pdev->dev, NULL);
./spi-sirf.c:	if (IS_ERR(sspi->clk)) {
./spi-sirf.c:		ret = PTR_ERR(sspi->clk);
./spi-sirf.c:	clk_prepare_enable(sspi->clk);
./spi-sirf.c:	sspi->ctrl_freq = clk_get_rate(sspi->clk);
./spi-sirf.c:	init_completion(&sspi->rx_done);
./spi-sirf.c:	init_completion(&sspi->tx_done);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_RXFIFO_OP);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_RXFIFO_OP);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:	writel(0, sspi->base + SIRFSOC_SPI_DUMMY_DELAY_CTL);
./spi-sirf.c:	sspi->dummypage = kmalloc(2 * PAGE_SIZE, GFP_KERNEL);
./spi-sirf.c:	if (!sspi->dummypage) {
./spi-sirf.c:	ret = spi_bitbang_start(&sspi->bitbang);
./spi-sirf.c:	kfree(sspi->dummypage);
./spi-sirf.c:	clk_disable_unprepare(sspi->clk);
./spi-sirf.c:	clk_put(sspi->clk);
./spi-sirf.c:	dma_release_channel(sspi->tx_chan);
./spi-sirf.c:	dma_release_channel(sspi->rx_chan);
./spi-sirf.c:	spi_bitbang_stop(&sspi->bitbang);
./spi-sirf.c:	kfree(sspi->dummypage);
./spi-sirf.c:	clk_disable_unprepare(sspi->clk);
./spi-sirf.c:	clk_put(sspi->clk);
./spi-sirf.c:	dma_release_channel(sspi->rx_chan);
./spi-sirf.c:	dma_release_channel(sspi->tx_chan);
./spi-sirf.c:	clk_disable(sspi->clk);
./spi-sirf.c:	clk_enable(sspi->clk);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_RXFIFO_OP);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_RESET, sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_RXFIFO_OP);
./spi-sirf.c:	writel(SIRFSOC_SPI_FIFO_START, sspi->base + SIRFSOC_SPI_TXFIFO_OP);
./spi-ti-qspi.c:	return readl(qspi->base + reg);
./spi-ti-qspi.c:	writel(val, qspi->base + reg);
./spi-ti-qspi.c:	struct ti_qspi	*qspi = spi_master_get_devdata(spi->master);
./spi-ti-qspi.c:	struct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;
./spi-ti-qspi.c:	if (spi->master->busy) {
./spi-ti-qspi.c:		dev_dbg(qspi->dev, "master busy doing other trasnfers\n");
./spi-ti-qspi.c:	if (!qspi->spi_max_frequency) {
./spi-ti-qspi.c:		dev_err(qspi->dev, "spi max frequency not defined\n");
./spi-ti-qspi.c:	clk_rate = clk_get_rate(qspi->fclk);
./spi-ti-qspi.c:	clk_div = DIV_ROUND_UP(clk_rate, qspi->spi_max_frequency) - 1;
./spi-ti-qspi.c:		dev_dbg(qspi->dev, "clock divider < 0, using /1 divider\n");
./spi-ti-qspi.c:		dev_dbg(qspi->dev, "clock divider >%d , using /%d divider\n",
./spi-ti-qspi.c:	dev_dbg(qspi->dev, "hz: %d, clock divider %d\n",
./spi-ti-qspi.c:			qspi->spi_max_frequency, clk_div);
./spi-ti-qspi.c:	ret = pm_runtime_get_sync(qspi->dev);
./spi-ti-qspi.c:		dev_err(qspi->dev, "pm_runtime_get_sync() failed\n");
./spi-ti-qspi.c:	pm_runtime_mark_last_busy(qspi->dev);
./spi-ti-qspi.c:	ret = pm_runtime_put_autosuspend(qspi->dev);
./spi-ti-qspi.c:		dev_err(qspi->dev, "pm_runtime_put_autosuspend() failed\n");
./spi-ti-qspi.c:	struct ti_qspi_regs *ctx_reg = &qspi->ctx_reg;
./spi-ti-qspi.c:	cmd = qspi->cmd | QSPI_WR_SNGL;
./spi-ti-qspi.c:			dev_dbg(qspi->dev, "tx cmd %08x dc %08x data %02x\n",
./spi-ti-qspi.c:					cmd, qspi->dc, *txbuf);
./spi-ti-qspi.c:			writeb(*txbuf, qspi->base + QSPI_SPI_DATA_REG);
./spi-ti-qspi.c:			dev_dbg(qspi->dev, "tx cmd %08x dc %08x data %04x\n",
./spi-ti-qspi.c:					cmd, qspi->dc, *txbuf);
./spi-ti-qspi.c:			writew(*((u16 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);
./spi-ti-qspi.c:			dev_dbg(qspi->dev, "tx cmd %08x dc %08x data %08x\n",
./spi-ti-qspi.c:					cmd, qspi->dc, *txbuf);
./spi-ti-qspi.c:			writel(*((u32 *)txbuf), qspi->base + QSPI_SPI_DATA_REG);
./spi-ti-qspi.c:		if (!wait_for_completion_timeout(&qspi->transfer_complete,
./spi-ti-qspi.c:			dev_err(qspi->dev, "write timed out\n");
./spi-ti-qspi.c:	cmd = qspi->cmd;
./spi-ti-qspi.c:		dev_dbg(qspi->dev, "rx cmd %08x dc %08x\n", cmd, qspi->dc);
./spi-ti-qspi.c:		if (!wait_for_completion_timeout(&qspi->transfer_complete,
./spi-ti-qspi.c:			dev_err(qspi->dev, "read timed out\n");
./spi-ti-qspi.c:			*rxbuf = readb(qspi->base + QSPI_SPI_DATA_REG);
./spi-ti-qspi.c:			*((u16 *)rxbuf) = readw(qspi->base + QSPI_SPI_DATA_REG);
./spi-ti-qspi.c:			*((u32 *)rxbuf) = readl(qspi->base + QSPI_SPI_DATA_REG);
./spi-ti-qspi.c:			dev_dbg(qspi->dev, "Error while writing\n");
./spi-ti-qspi.c:			dev_dbg(qspi->dev, "Error while reading\n");
./spi-ti-qspi.c:	qspi->dc = 0;
./spi-ti-qspi.c:	if (spi->mode & SPI_CPHA)
./spi-ti-qspi.c:		qspi->dc |= QSPI_CKPHA(spi->chip_select);
./spi-ti-qspi.c:	if (spi->mode & SPI_CPOL)
./spi-ti-qspi.c:		qspi->dc |= QSPI_CKPOL(spi->chip_select);
./spi-ti-qspi.c:	if (spi->mode & SPI_CS_HIGH)
./spi-ti-qspi.c:		qspi->dc |= QSPI_CSPOL(spi->chip_select);
./spi-ti-qspi.c:	frame_length = (m->frame_length << 3) / spi->bits_per_word;
./spi-ti-qspi.c:	qspi->cmd = 0;
./spi-ti-qspi.c:	qspi->cmd |= QSPI_EN_CS(spi->chip_select);
./spi-ti-qspi.c:	qspi->cmd |= QSPI_FLEN(frame_length);
./spi-ti-qspi.c:	qspi->cmd |= QSPI_WC_CMD_INT_EN;
./spi-ti-qspi.c:	ti_qspi_write(qspi, qspi->dc, QSPI_SPI_DC_REG);
./spi-ti-qspi.c:	mutex_lock(&qspi->list_lock);
./spi-ti-qspi.c:		qspi->cmd |= QSPI_WLEN(t->bits_per_word);
./spi-ti-qspi.c:			dev_dbg(qspi->dev, "transfer message failed\n");
./spi-ti-qspi.c:			mutex_unlock(&qspi->list_lock);
./spi-ti-qspi.c:	mutex_unlock(&qspi->list_lock);
./spi-ti-qspi.c:	ti_qspi_write(qspi, qspi->cmd | QSPI_INVAL, QSPI_SPI_CMD_REG);
./spi-ti-qspi.c:		dev_dbg(qspi->dev, "No IRQ triggered\n");
./spi-ti-qspi.c:		complete(&qspi->transfer_complete);
./spi-ti-qspi.c:	qspi->master = master;
./spi-ti-qspi.c:	qspi->dev = &pdev->dev;
./spi-ti-qspi.c:	mutex_init(&qspi->list_lock);
./spi-ti-qspi.c:	qspi->base = devm_ioremap_resource(&pdev->dev, r);
./spi-ti-qspi.c:	if (IS_ERR(qspi->base)) {
./spi-ti-qspi.c:		ret = PTR_ERR(qspi->base);
./spi-ti-qspi.c:		qspi->ctrl_mod = true;
./spi-ti-qspi.c:		qspi->ctrl_base = devm_ioremap_resource(&pdev->dev, res_ctrl);
./spi-ti-qspi.c:		if (IS_ERR(qspi->ctrl_base)) {
./spi-ti-qspi.c:			ret = PTR_ERR(qspi->ctrl_base);
./spi-ti-qspi.c:		qspi->mmap_base = devm_ioremap_resource(&pdev->dev, res_mmap);
./spi-ti-qspi.c:		if (IS_ERR(qspi->mmap_base)) {
./spi-ti-qspi.c:			ret = PTR_ERR(qspi->mmap_base);
./spi-ti-qspi.c:	qspi->fclk = devm_clk_get(&pdev->dev, "fck");
./spi-ti-qspi.c:	if (IS_ERR(qspi->fclk)) {
./spi-ti-qspi.c:		ret = PTR_ERR(qspi->fclk);
./spi-ti-qspi.c:	init_completion(&qspi->transfer_complete);
./spi-ti-qspi.c:	if (!of_property_read_u32(np, "spi-max-frequency", &max_freq))
./spi-ti-qspi.c:		qspi->spi_max_frequency = max_freq;
./spi-ti-qspi.c:	ret = pm_runtime_get_sync(qspi->dev);
./spi-ti-qspi.c:		dev_err(qspi->dev, "pm_runtime_get_sync() failed\n");
./spi-ti-qspi.c:	pm_runtime_put(qspi->dev);
./spi-oc-tiny.c:		gpio_set_value(hw->gpio_cs[spi->chip_select],
./spi-oc-tiny.c:			(spi->mode & SPI_CS_HIGH) ? is_active : !is_active);
./spi-oc-tiny.c:	if (spi->max_speed_hz != hw->speed_hz) {
./spi-oc-tiny.c:		hw->speed_hz = spi->max_speed_hz;
./spi-oc-tiny.c:	hw->mode = spi->mode & (SPI_CPOL | SPI_CPHA);
./spi-oc-tiny.c:	{ .compatible = "opencores,tiny-spi-rtlsvn2", },
./spi-rockchip.c:	struct rockchip_spi *rs = spi_master_get_devdata(spi->master);
./spi-rockchip.c:	 *		if (spi->mode & SPI_CS_HIGH)
./spi-rockchip.c:	 *		if (spi->cs_gpio >= 0)
./spi-rockchip.c:	 *			gpio_set_value(spi->cs_gpio, !enable);
./spi-rockchip.c:	 *		else if (spi->master->set_cs)
./spi-rockchip.c:	 *		spi->master->set_cs(spi, !enable);
./spi-rockchip.c:		ser |= 1 << spi->chip_select;
./spi-rockchip.c:		ser &= ~(1 << spi->chip_select);
./spi-rockchip.c:	rs->mode = spi->mode;
./spi-atmel.c:	struct atmel_spi_device *asd = spi->controller_state;
./spi-atmel.c:	unsigned active = spi->mode & SPI_CS_HIGH;
./spi-atmel.c:		spi_writel(as, CSR0 + 4 * spi->chip_select, asd->csr);
./spi-atmel.c:					SPI_BF(PCS, ~(0x01 << spi->chip_select))
./spi-atmel.c:					SPI_BF(PCS, ~(0x01 << spi->chip_select))
./spi-atmel.c:		u32 cpol = (spi->mode & SPI_CPOL) ? SPI_BIT(CPOL) : 0;
./spi-atmel.c:		for (i = 0; i < spi->master->num_chipselect; i++) {
./spi-atmel.c:		mr = SPI_BFINS(PCS, ~(1 << spi->chip_select), mr);
./spi-atmel.c:		if (spi->chip_select != 0)
./spi-atmel.c:	dev_dbg(&spi->dev, "activate %u%s, mr %08x\n",
./spi-atmel.c:	struct atmel_spi_device *asd = spi->controller_state;
./spi-atmel.c:	unsigned active = spi->mode & SPI_CS_HIGH;
./spi-atmel.c:	if (~SPI_BFEXT(PCS, mr) & (1 << spi->chip_select)) {
./spi-atmel.c:	dev_dbg(&spi->dev, "DEactivate %u%s, mr %08x\n",
./spi-atmel.c:	if (atmel_spi_is_v2(as) || spi->chip_select != 0)
./spi-atmel.c:		dev_err(&spi->dev,
./spi-atmel.c:		dev_err(&spi->dev,
./spi-atmel.c:	csr = spi_readl(as, CSR0 + 4 * spi->chip_select);
./spi-atmel.c:	spi_writel(as, CSR0 + 4 * spi->chip_select, csr);
./spi-atmel.c:	if (msg->spi->bits_per_word > 8)
./spi-atmel.c:	dev_dbg(&msg->spi->dev,
./spi-atmel.c:		if (msg->spi->bits_per_word > 8)
./spi-atmel.c:		dev_dbg(&msg->spi->dev,
./spi-atmel.c:	unsigned int		bits = spi->bits_per_word;
./spi-atmel.c:	as = spi_master_get_devdata(spi->master);
./spi-atmel.c:			&& spi->chip_select == 0
./spi-atmel.c:			&& (spi->mode & SPI_CS_HIGH)) {
./spi-atmel.c:		dev_dbg(&spi->dev, "setup: can't be active-high\n");
./spi-atmel.c:	if (spi->mode & SPI_CPOL)
./spi-atmel.c:	if (!(spi->mode & SPI_CPHA))
./spi-atmel.c:	npcs_pin = (unsigned long)spi->controller_data;
./spi-atmel.c:	if (gpio_is_valid(spi->cs_gpio))
./spi-atmel.c:		npcs_pin = spi->cs_gpio;
./spi-atmel.c:	asd = spi->controller_state;
./spi-atmel.c:		ret = gpio_request(npcs_pin, dev_name(&spi->dev));
./spi-atmel.c:		spi->controller_state = asd;
./spi-atmel.c:		gpio_direction_output(npcs_pin, !(spi->mode & SPI_CS_HIGH));
./spi-atmel.c:	dev_dbg(&spi->dev,
./spi-atmel.c:		bits, spi->mode, spi->chip_select, csr);
./spi-atmel.c:		spi_writel(as, CSR0 + 4 * spi->chip_select, csr);
./spi-atmel.c:		dev_dbg(&spi->dev, "missing rx or tx buf\n");
./spi-atmel.c:		asd = spi->controller_state;
./spi-atmel.c:			dev_dbg(&spi->dev,
./spi-atmel.c:				dev_err(&spi->dev,
./spi-atmel.c:			dev_err(&spi->dev, "spi transfer timeout\n");
./spi-atmel.c:	dev_dbg(&spi->dev, "new message %p submitted for %s\n",
./spi-atmel.c:					msg, dev_name(&spi->dev));
./spi-atmel.c:		dev_dbg(&spi->dev,
./spi-atmel.c:	spi_finalize_current_message(spi->master);
./spi-atmel.c:	struct atmel_spi_device	*asd = spi->controller_state;
./spi-atmel.c:	unsigned		gpio = (unsigned long) spi->controller_data;
./spi-atmel.c:	spi->controller_state = NULL;
./spi-atmel.c:	/* the spi->mode bits understood by this driver: */
./spi-sh.c:	struct spi_sh_data *ss = spi_master_get_devdata(spi->master);
./spi-sh.c:	struct spi_sh_data *ss = spi_master_get_devdata(spi->master);
./spi-sh.c:	pr_debug("\tmode = %02x\n", spi->mode);
./spi-sh.c:	struct spi_sh_data *ss = spi_master_get_devdata(spi->master);
./spi-pl022.c:	pl022->cur_cs = pl022->chipselects[msg->spi->chip_select];
./spi-pl022.c:	struct pl022 *pl022 = spi_master_get_devdata(spi->master);
./spi-pl022.c:	unsigned int bits = spi->bits_per_word;
./spi-pl022.c:	struct device_node *np = spi->dev.of_node;
./spi-pl022.c:	if (!spi->max_speed_hz)
./spi-pl022.c:		dev_dbg(&spi->dev,
./spi-pl022.c:	chip_info = spi->controller_data;
./spi-pl022.c:			dev_dbg(&spi->dev,
./spi-pl022.c:		dev_dbg(&spi->dev,
./spi-pl022.c:						  spi->max_speed_hz,
./spi-pl022.c:		dev_err(&spi->dev,
./spi-pl022.c:		dev_err(&spi->dev, "controller data is incorrect");
./spi-pl022.c:		if (!gpio_is_valid(pl022->chipselects[spi->chip_select]))
./spi-pl022.c:			dev_warn(&spi->dev,
./spi-pl022.c:		dev_err(&spi->dev, "illegal data size for this controller!\n");
./spi-pl022.c:		dev_err(&spi->dev, "This controller can only handle 4 <= n <= %d bit words\n",
./spi-pl022.c:		dev_dbg(&spi->dev, "4 <= n <=8 bits per word\n");
./spi-pl022.c:		dev_dbg(&spi->dev, "9 <= n <= 16 bits per word\n");
./spi-pl022.c:		dev_dbg(&spi->dev, "17 <= n <= 32 bits per word\n");
./spi-pl022.c:		dev_dbg(&spi->dev, "DMA mode set in controller state\n");
./spi-pl022.c:		dev_dbg(&spi->dev, "DMA mode NOT set in controller state\n");
./spi-pl022.c:		if (spi->mode & SPI_LSB_FIRST) {
./spi-pl022.c:	if (spi->mode & SPI_CPOL)
./spi-pl022.c:	if (spi->mode & SPI_CPHA)
./spi-pl022.c:		if (spi->mode & SPI_LOOP)
./spi-sun6i.c:	return readl(sspi->base_addr + reg);
./spi-sun6i.c:	writel(value, sspi->base_addr + reg);
./spi-sun6i.c:		byte = readb(sspi->base_addr + SUN6I_RXDATA_REG);
./spi-sun6i.c:		if (sspi->rx_buf)
./spi-sun6i.c:			*sspi->rx_buf++ = byte;
./spi-sun6i.c:	if (len > sspi->len)
./spi-sun6i.c:		len = sspi->len;
./spi-sun6i.c:		byte = sspi->tx_buf ? *sspi->tx_buf++ : 0;
./spi-sun6i.c:		writeb(byte, sspi->base_addr + SUN6I_TXDATA_REG);
./spi-sun6i.c:		sspi->len--;
./spi-sun6i.c:	struct sun6i_spi *sspi = spi_master_get_devdata(spi->master);
./spi-sun6i.c:	reg |= SUN6I_TFR_CTL_CS(spi->chip_select);
./spi-sun6i.c:	reinit_completion(&sspi->done);
./spi-sun6i.c:	sspi->tx_buf = tfr->tx_buf;
./spi-sun6i.c:	sspi->rx_buf = tfr->rx_buf;
./spi-sun6i.c:	sspi->len = tfr->len;
./spi-sun6i.c:	if (spi->mode & SPI_CPOL)
./spi-sun6i.c:	if (spi->mode & SPI_CPHA)
./spi-sun6i.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-sun6i.c:	if (sspi->rx_buf)
./spi-sun6i.c:	mclk_rate = clk_get_rate(sspi->mclk);
./spi-sun6i.c:	if (mclk_rate < (2 * spi->max_speed_hz)) {
./spi-sun6i.c:		clk_set_rate(sspi->mclk, 2 * spi->max_speed_hz);
./spi-sun6i.c:		mclk_rate = clk_get_rate(sspi->mclk);
./spi-sun6i.c:	div = mclk_rate / (2 * spi->max_speed_hz);
./spi-sun6i.c:		div = ilog2(mclk_rate) - ilog2(spi->max_speed_hz);
./spi-sun6i.c:	if (sspi->tx_buf)
./spi-sun6i.c:	timeout = wait_for_completion_timeout(&sspi->done,
./spi-sun6i.c:		complete(&sspi->done);
./spi-sun6i.c:	ret = clk_prepare_enable(sspi->hclk);
./spi-sun6i.c:	ret = clk_prepare_enable(sspi->mclk);
./spi-sun6i.c:	ret = reset_control_deassert(sspi->rstc);
./spi-sun6i.c:	clk_disable_unprepare(sspi->mclk);
./spi-sun6i.c:	clk_disable_unprepare(sspi->hclk);
./spi-sun6i.c:	reset_control_assert(sspi->rstc);
./spi-sun6i.c:	clk_disable_unprepare(sspi->mclk);
./spi-sun6i.c:	clk_disable_unprepare(sspi->hclk);
./spi-sun6i.c:	sspi->base_addr = devm_ioremap_resource(&pdev->dev, res);
./spi-sun6i.c:	if (IS_ERR(sspi->base_addr)) {
./spi-sun6i.c:		ret = PTR_ERR(sspi->base_addr);
./spi-sun6i.c:	sspi->master = master;
./spi-sun6i.c:	sspi->hclk = devm_clk_get(&pdev->dev, "ahb");
./spi-sun6i.c:	if (IS_ERR(sspi->hclk)) {
./spi-sun6i.c:		ret = PTR_ERR(sspi->hclk);
./spi-sun6i.c:	sspi->mclk = devm_clk_get(&pdev->dev, "mod");
./spi-sun6i.c:	if (IS_ERR(sspi->mclk)) {
./spi-sun6i.c:		ret = PTR_ERR(sspi->mclk);
./spi-sun6i.c:	init_completion(&sspi->done);
./spi-sun6i.c:	sspi->rstc = devm_reset_control_get(&pdev->dev, NULL);
./spi-sun6i.c:	if (IS_ERR(sspi->rstc)) {
./spi-sun6i.c:		ret = PTR_ERR(sspi->rstc);
./spi-topcliff-pch.c:	dev_dbg(&spi->dev, "%s SPBRR content =%x setting baud rate=%d\n",
./spi-topcliff-pch.c:		__func__, pch_spi_readreg(spi->master, PCH_SPBRR),
./spi-topcliff-pch.c:		spi->max_speed_hz);
./spi-topcliff-pch.c:	pch_spi_set_baud_rate(spi->master, spi->max_speed_hz);
./spi-topcliff-pch.c:	pch_spi_set_bits_per_word(spi->master, spi->bits_per_word);
./spi-topcliff-pch.c:	if (!(spi->mode & SPI_LSB_FIRST))
./spi-topcliff-pch.c:	if (spi->mode & SPI_CPOL)
./spi-topcliff-pch.c:	if (spi->mode & SPI_CPHA)
./spi-topcliff-pch.c:	pch_spi_setclr_reg(spi->master, PCH_SPCR, flags,
./spi-topcliff-pch.c:	pch_spi_clear_fifo(spi->master);
./spi-topcliff-pch.c:	struct pch_spi_data *data = spi_master_get_devdata(pspi->master);
./spi-topcliff-pch.c:			dev_err(&pspi->dev,
./spi-topcliff-pch.c:			dev_err(&pspi->dev, "%s Transfer length invalid\n",
./spi-topcliff-pch.c:		dev_dbg(&pspi->dev,
./spi-topcliff-pch.c:		dev_err(&pspi->dev, "%s status = STATUS_EXITING.\n", __func__);
./spi-topcliff-pch.c:		dev_err(&pspi->dev, "%s suspend; returning EINVAL\n", __func__);
./spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s - pmsg->status =%d\n", __func__, pmsg->status);
./spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s - Invoked list_add_tail\n", __func__);
./spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s - Invoked queue work\n", __func__);
./spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s RETURN=%d\n", __func__, retval);
./spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s RETURN=%d\n", __func__, retval);
./spi-topcliff-pch.c:		if (pspi->chip_select != data->n_curnt_chip) {
./spi-topcliff-pch.c:			dev_dbg(&pspi->dev, "%s : different slave\n", __func__);
./spi-topcliff-pch.c:	dev_dbg(&pspi->dev, "%s :Invoking pch_spi_setup_transfer\n", __func__);
./spi-topcliff-pch.c:	    (data->current_msg->spi->bits_per_word != data->cur_trans->bits_per_word)) {
./spi-topcliff-pch.c:		*bpw = data->current_msg->spi->bits_per_word;
./spi-topcliff-pch.c:	    (data->current_msg->spi->bits_per_word !=
./spi-topcliff-pch.c:		*bpw = data->current_msg->spi->bits_per_word;
./spi-topcliff-pch.c:				    data->current_msg->spi->bits_per_word);
./spi-bcm63xx-hsspi.c:	unsigned profile = spi->chip_select;
./spi-bcm63xx-hsspi.c:	if (spi->mode & SPI_CPOL)
./spi-bcm63xx-hsspi.c:	struct bcm63xx_hsspi *bs = spi_master_get_devdata(spi->master);
./spi-bcm63xx-hsspi.c:	unsigned chip_select = spi->chip_select;
./spi-bcm63xx-hsspi.c:	bcm63xx_hsspi_set_cs(bs, spi->chip_select, true);
./spi-bcm63xx-hsspi.c:	struct bcm63xx_hsspi *bs = spi_master_get_devdata(spi->master);
./spi-bcm63xx-hsspi.c:			  HSSPI_PROFILE_SIGNAL_CTRL_REG(spi->chip_select));
./spi-bcm63xx-hsspi.c:	if (spi->mode & SPI_CPHA)
./spi-bcm63xx-hsspi.c:		     HSSPI_PROFILE_SIGNAL_CTRL_REG(spi->chip_select));
./spi-bcm63xx-hsspi.c:		if (spi->mode & SPI_CS_HIGH)
./spi-bcm63xx-hsspi.c:			reg |= BIT(spi->chip_select);
./spi-bcm63xx-hsspi.c:			reg &= ~BIT(spi->chip_select);
./spi-bcm63xx-hsspi.c:	if (spi->mode & SPI_CS_HIGH)
./spi-bcm63xx-hsspi.c:		bs->cs_polarity |= BIT(spi->chip_select);
./spi-bcm63xx-hsspi.c:		bs->cs_polarity &= ~BIT(spi->chip_select);
./spi-bcm63xx-hsspi.c:	dummy_cs = !spi->chip_select;
./spi-bcm63xx-hsspi.c:			bcm63xx_hsspi_set_cs(bs, spi->chip_select, false);
./spi-gpio.c: * spi->controller_state ... reserved for bitbang framework code
./spi-gpio.c: * spi->controller_data ... holds chipselect GPIO
./spi-gpio.c: * spi->master->dev.driver_data ... points to spi_gpio->bitbang
./spi-gpio.c: *		#include "spi-gpio.c"
./spi-gpio.c:	bang = spi_master_get_devdata(spi->master);
./spi-gpio.c:#include "spi-bitbang-txrx.h"
./spi-gpio.c:	unsigned flags = spi->master->flags;
./spi-gpio.c:	unsigned flags = spi->master->flags;
./spi-gpio.c:	unsigned flags = spi->master->flags;
./spi-gpio.c:	unsigned flags = spi->master->flags;
./spi-gpio.c:	unsigned long cs = spi_gpio->cs_gpios[spi->chip_select];
./spi-gpio.c:		setsck(spi, spi->mode & SPI_CPOL);
./spi-gpio.c:		gpio_set_value_cansleep(cs, (spi->mode & SPI_CS_HIGH) ? is_active : !is_active);
./spi-gpio.c:	struct device_node	*np = spi->master->dev.of_node;
./spi-gpio.c:		cs = spi_gpio->cs_gpios[spi->chip_select];
./spi-gpio.c:		 * ... otherwise, take it from spi->controller_data
./spi-gpio.c:		cs = (uintptr_t) spi->controller_data;
./spi-gpio.c:	if (!spi->controller_state) {
./spi-gpio.c:			status = gpio_request(cs, dev_name(&spi->dev));
./spi-gpio.c:					!(spi->mode & SPI_CS_HIGH));
./spi-gpio.c:		spi_gpio->cs_gpios[spi->chip_select] = cs;
./spi-gpio.c:		if (!spi->controller_state && cs != SPI_GPIO_NO_CHIPSELECT)
./spi-gpio.c:	unsigned long cs = spi_gpio->cs_gpios[spi->chip_select];
./spi-gpio.c:	{ .compatible = "spi-gpio" },
./spi-nuc900.c:#include <linux/platform_data/spi-nuc900.h>
./spi-nuc900.c:	unsigned int cs = spi->mode & SPI_CS_HIGH ? 1 : 0;
./spi-nuc900.c:	unsigned int cpol = spi->mode & SPI_CPOL ? 1 : 0;
./spi-fsl-dspi.c: * drivers/spi/spi-fsl-dspi.c
./spi-fsl-dspi.c:	regmap_read(dspi->regmap, SPI_CTAR(dspi->cs), &val);
./spi-fsl-dspi.c:	if (tx_word && (dspi->len == 1)) {
./spi-fsl-dspi.c:		dspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;
./spi-fsl-dspi.c:		regmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),
./spi-fsl-dspi.c:	while (dspi->len && (tx_count < DSPI_FIFO_SIZE)) {
./spi-fsl-dspi.c:			if (dspi->len == 1)
./spi-fsl-dspi.c:			if (!(dspi->dataflags & TRAN_STATE_TX_VOID)) {
./spi-fsl-dspi.c:				d16 = *(u16 *)dspi->tx;
./spi-fsl-dspi.c:				dspi->tx += 2;
./spi-fsl-dspi.c:				d16 = dspi->void_write_data;
./spi-fsl-dspi.c:				SPI_PUSHR_PCS(dspi->cs) |
./spi-fsl-dspi.c:				SPI_PUSHR_CTAS(dspi->cs) |
./spi-fsl-dspi.c:			dspi->len -= 2;
./spi-fsl-dspi.c:			if (!(dspi->dataflags & TRAN_STATE_TX_VOID)) {
./spi-fsl-dspi.c:				d8 = *(u8 *)dspi->tx;
./spi-fsl-dspi.c:				dspi->tx++;
./spi-fsl-dspi.c:				d8 = (u8)dspi->void_write_data;
./spi-fsl-dspi.c:				SPI_PUSHR_PCS(dspi->cs) |
./spi-fsl-dspi.c:				SPI_PUSHR_CTAS(dspi->cs) |
./spi-fsl-dspi.c:			dspi->len--;
./spi-fsl-dspi.c:		if (dspi->len == 0 || tx_count == DSPI_FIFO_SIZE - 1) {
./spi-fsl-dspi.c:			if ((dspi->cs_change) && (!dspi->len))
./spi-fsl-dspi.c:		} else if (tx_word && (dspi->len == 1))
./spi-fsl-dspi.c:		regmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);
./spi-fsl-dspi.c:	while ((dspi->rx < dspi->rx_end)
./spi-fsl-dspi.c:			if ((dspi->rx_end - dspi->rx) == 1)
./spi-fsl-dspi.c:			regmap_read(dspi->regmap, SPI_POPR, &val);
./spi-fsl-dspi.c:			if (!(dspi->dataflags & TRAN_STATE_RX_VOID))
./spi-fsl-dspi.c:				*(u16 *)dspi->rx = d;
./spi-fsl-dspi.c:			dspi->rx += 2;
./spi-fsl-dspi.c:			regmap_read(dspi->regmap, SPI_POPR, &val);
./spi-fsl-dspi.c:			if (!(dspi->dataflags & TRAN_STATE_RX_VOID))
./spi-fsl-dspi.c:				*(u8 *)dspi->rx = d;
./spi-fsl-dspi.c:			dspi->rx++;
./spi-fsl-dspi.c:		dspi->cur_transfer = transfer;
./spi-fsl-dspi.c:		dspi->cur_msg = message;
./spi-fsl-dspi.c:		dspi->cur_chip = spi_get_ctldata(spi);
./spi-fsl-dspi.c:		dspi->cs = spi->chip_select;
./spi-fsl-dspi.c:		if (dspi->cur_transfer->transfer_list.next
./spi-fsl-dspi.c:				== &dspi->cur_msg->transfers)
./spi-fsl-dspi.c:		dspi->cs_change = transfer->cs_change;
./spi-fsl-dspi.c:		dspi->void_write_data = dspi->cur_chip->void_write_data;
./spi-fsl-dspi.c:		dspi->dataflags = 0;
./spi-fsl-dspi.c:		dspi->tx = (void *)transfer->tx_buf;
./spi-fsl-dspi.c:		dspi->tx_end = dspi->tx + transfer->len;
./spi-fsl-dspi.c:		dspi->rx = transfer->rx_buf;
./spi-fsl-dspi.c:		dspi->rx_end = dspi->rx + transfer->len;
./spi-fsl-dspi.c:		dspi->len = transfer->len;
./spi-fsl-dspi.c:		if (!dspi->rx)
./spi-fsl-dspi.c:			dspi->dataflags |= TRAN_STATE_RX_VOID;
./spi-fsl-dspi.c:		if (!dspi->tx)
./spi-fsl-dspi.c:			dspi->dataflags |= TRAN_STATE_TX_VOID;
./spi-fsl-dspi.c:		regmap_write(dspi->regmap, SPI_MCR, dspi->cur_chip->mcr_val);
./spi-fsl-dspi.c:		regmap_update_bits(dspi->regmap, SPI_MCR,
./spi-fsl-dspi.c:		regmap_write(dspi->regmap, SPI_CTAR(dspi->cs),
./spi-fsl-dspi.c:				dspi->cur_chip->ctar_val);
./spi-fsl-dspi.c:			regmap_write(dspi->regmap, SPI_CTAR(dspi->cs),
./spi-fsl-dspi.c:					dspi->cur_chip->ctar_val);
./spi-fsl-dspi.c:		regmap_write(dspi->regmap, SPI_RSER, SPI_RSER_EOQFE);
./spi-fsl-dspi.c:		if (wait_event_interruptible(dspi->waitq, dspi->waitflags))
./spi-fsl-dspi.c:			dev_err(&dspi->pdev->dev, "wait transfer complete fail!\n");
./spi-fsl-dspi.c:		dspi->waitflags = 0;
./spi-fsl-dspi.c:	struct fsl_dspi *dspi = spi_master_get_devdata(spi->master);
./spi-fsl-dspi.c:	if ((spi->bits_per_word >= 4) && (spi->bits_per_word <= 16)) {
./spi-fsl-dspi.c:		fmsz = spi->bits_per_word - 1;
./spi-fsl-dspi.c:	of_property_read_u32(spi->dev.of_node, "fsl,spi-cs-sck-delay",
./spi-fsl-dspi.c:	of_property_read_u32(spi->dev.of_node, "fsl,spi-sck-cs-delay",
./spi-fsl-dspi.c:	clkrate = clk_get_rate(dspi->clk);
./spi-fsl-dspi.c:	hz_to_spi_baud(&pbr, &br, spi->max_speed_hz, clkrate);
./spi-fsl-dspi.c:		| SPI_CTAR_CPOL(spi->mode & SPI_CPOL ? 1 : 0)
./spi-fsl-dspi.c:		| SPI_CTAR_CPHA(spi->mode & SPI_CPHA ? 1 : 0)
./spi-fsl-dspi.c:		| SPI_CTAR_LSBFE(spi->mode & SPI_LSB_FIRST ? 1 : 0)
./spi-fsl-dspi.c:	dev_dbg(&spi->dev, "spi_device %u.%u cleanup\n",
./spi-fsl-dspi.c:			spi->master->bus_num, spi->chip_select);
./spi-fsl-dspi.c:	struct spi_message *msg = dspi->cur_msg;
./spi-fsl-dspi.c:	regmap_write(dspi->regmap, SPI_SR, SPI_SR_EOQF);
./spi-fsl-dspi.c:	if (!dspi->len) {
./spi-fsl-dspi.c:		if (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM)
./spi-fsl-dspi.c:			regmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),
./spi-fsl-dspi.c:		dspi->waitflags = 1;
./spi-fsl-dspi.c:		wake_up_interruptible(&dspi->waitq);
./spi-fsl-dspi.c:	clk_disable_unprepare(dspi->clk);
./spi-fsl-dspi.c:	clk_prepare_enable(dspi->clk);
./spi-fsl-dspi.c:	dspi->pdev = pdev;
./spi-fsl-dspi.c:	dspi->master = master;
./spi-fsl-dspi.c:	ret = of_property_read_u32(np, "spi-num-chipselects", &cs_num);
./spi-fsl-dspi.c:		dev_err(&pdev->dev, "can't get spi-num-chipselects\n");
./spi-fsl-dspi.c:	dspi->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "dspi", base,
./spi-fsl-dspi.c:	if (IS_ERR(dspi->regmap)) {
./spi-fsl-dspi.c:				PTR_ERR(dspi->regmap));
./spi-fsl-dspi.c:		return PTR_ERR(dspi->regmap);
./spi-fsl-dspi.c:	dspi->irq = platform_get_irq(pdev, 0);
./spi-fsl-dspi.c:	if (dspi->irq < 0) {
./spi-fsl-dspi.c:		ret = dspi->irq;
./spi-fsl-dspi.c:	ret = devm_request_irq(&pdev->dev, dspi->irq, dspi_interrupt, 0,
./spi-fsl-dspi.c:	dspi->clk = devm_clk_get(&pdev->dev, "dspi");
./spi-fsl-dspi.c:	if (IS_ERR(dspi->clk)) {
./spi-fsl-dspi.c:		ret = PTR_ERR(dspi->clk);
./spi-fsl-dspi.c:	clk_prepare_enable(dspi->clk);
./spi-fsl-dspi.c:	init_waitqueue_head(&dspi->waitq);
./spi-fsl-dspi.c:	clk_disable_unprepare(dspi->clk);
./spi-fsl-dspi.c:	clk_disable_unprepare(dspi->clk);
./spi-fsl-dspi.c:	spi_unregister_master(dspi->master);
./spi-fsl-dspi.c:	spi_master_put(dspi->master);
./spi-fsl-spi.c:#include "spi-fsl-lib.h"
./spi-fsl-spi.c:#include "spi-fsl-cpm.h"
./spi-fsl-spi.c:#include "spi-fsl-spi.h"
./spi-fsl-spi.c:	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
./spi-fsl-spi.c:	struct spi_mpc8xxx_cs *cs = spi->controller_state;
./spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
./spi-fsl-spi.c:	if (mspi->flags & SPI_CPM_MODE) {
./spi-fsl-spi.c:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
./spi-fsl-spi.c:	bool pol = spi->mode & SPI_CS_HIGH;
./spi-fsl-spi.c:	struct spi_mpc8xxx_cs	*cs = spi->controller_state;
./spi-fsl-spi.c:	pdata = spi->dev.parent->parent->platform_data;
./spi-fsl-spi.c:		mpc8xxx_spi->rx_shift = cs->rx_shift;
./spi-fsl-spi.c:		mpc8xxx_spi->tx_shift = cs->tx_shift;
./spi-fsl-spi.c:		mpc8xxx_spi->get_rx = cs->get_rx;
./spi-fsl-spi.c:		mpc8xxx_spi->get_tx = cs->get_tx;
./spi-fsl-spi.c:	if (mpc8xxx_spi->set_shifts)
./spi-fsl-spi.c:		mpc8xxx_spi->set_shifts(&cs->rx_shift, &cs->tx_shift,
./spi-fsl-spi.c:					!(spi->mode & SPI_LSB_FIRST));
./spi-fsl-spi.c:	mpc8xxx_spi->rx_shift = cs->rx_shift;
./spi-fsl-spi.c:	mpc8xxx_spi->tx_shift = cs->tx_shift;
./spi-fsl-spi.c:	mpc8xxx_spi->get_rx = cs->get_rx;
./spi-fsl-spi.c:	mpc8xxx_spi->get_tx = cs->get_tx;
./spi-fsl-spi.c:	if (spi->mode & SPI_LSB_FIRST &&
./spi-fsl-spi.c:	struct spi_mpc8xxx_cs	*cs = spi->controller_state;
./spi-fsl-spi.c:	mpc8xxx_spi = spi_master_get_devdata(spi->master);
./spi-fsl-spi.c:		bits_per_word = spi->bits_per_word;
./spi-fsl-spi.c:		hz = spi->max_speed_hz;
./spi-fsl-spi.c:	if (!(mpc8xxx_spi->flags & SPI_CPM_MODE))
./spi-fsl-spi.c:	else if (mpc8xxx_spi->flags & SPI_QE)
./spi-fsl-spi.c:	if ((mpc8xxx_spi->spibrg / hz) > 64) {
./spi-fsl-spi.c:		pm = (mpc8xxx_spi->spibrg - 1) / (hz * 64) + 1;
./spi-fsl-spi.c:			  "Will use %d Hz instead.\n", dev_name(&spi->dev),
./spi-fsl-spi.c:			  hz, mpc8xxx_spi->spibrg / 1024);
./spi-fsl-spi.c:		pm = (mpc8xxx_spi->spibrg - 1) / (hz * 4) + 1;
./spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
./spi-fsl-spi.c:	mspi->count = len;
./spi-fsl-spi.c:	word = mspi->get_tx(mspi);
./spi-fsl-spi.c:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
./spi-fsl-spi.c:	reg_base = mpc8xxx_spi->reg_base;
./spi-fsl-spi.c:	bits_per_word = spi->bits_per_word;
./spi-fsl-spi.c:	mpc8xxx_spi->tx = t->tx_buf;
./spi-fsl-spi.c:	mpc8xxx_spi->rx = t->rx_buf;
./spi-fsl-spi.c:	reinit_completion(&mpc8xxx_spi->done);
./spi-fsl-spi.c:	if (mpc8xxx_spi->flags & SPI_CPM_MODE)
./spi-fsl-spi.c:	wait_for_completion(&mpc8xxx_spi->done);
./spi-fsl-spi.c:	if (mpc8xxx_spi->flags & SPI_CPM_MODE)
./spi-fsl-spi.c:	return mpc8xxx_spi->count;
./spi-fsl-spi.c:			dev_err(&spi->dev,
./spi-fsl-spi.c:	if (!spi->max_speed_hz)
./spi-fsl-spi.c:	mpc8xxx_spi = spi_master_get_devdata(spi->master);
./spi-fsl-spi.c:	reg_base = mpc8xxx_spi->reg_base;
./spi-fsl-spi.c:	if (spi->mode & SPI_CPHA)
./spi-fsl-spi.c:	if (spi->mode & SPI_CPOL)
./spi-fsl-spi.c:	if (!(spi->mode & SPI_LSB_FIRST))
./spi-fsl-spi.c:	if (spi->mode & SPI_LOOP)
./spi-fsl-spi.c:	if (mpc8xxx_spi->type == TYPE_GRLIB) {
./spi-fsl-spi.c:		if (gpio_is_valid(spi->cs_gpio)) {
./spi-fsl-spi.c:			retval = gpio_request(spi->cs_gpio,
./spi-fsl-spi.c:					      dev_name(&spi->dev));
./spi-fsl-spi.c:			desel = !(spi->mode & SPI_CS_HIGH);
./spi-fsl-spi.c:			retval = gpio_direction_output(spi->cs_gpio, desel);
./spi-fsl-spi.c:				gpio_free(spi->cs_gpio);
./spi-fsl-spi.c:		} else if (spi->cs_gpio != -ENOENT) {
./spi-fsl-spi.c:			if (spi->cs_gpio < 0)
./spi-fsl-spi.c:				return spi->cs_gpio;
./spi-fsl-spi.c:		/* When spi->cs_gpio == -ENOENT, a hole in the phandle list
./spi-fsl-spi.c:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
./spi-fsl-spi.c:	if (mpc8xxx_spi->type == TYPE_GRLIB && gpio_is_valid(spi->cs_gpio))
./spi-fsl-spi.c:		gpio_free(spi->cs_gpio);
./spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
./spi-fsl-spi.c:		if (mspi->rx)
./spi-fsl-spi.c:			mspi->get_rx(rx_data, mspi);
./spi-fsl-spi.c:	mspi->count -= 1;
./spi-fsl-spi.c:	if (mspi->count) {
./spi-fsl-spi.c:		u32 word = mspi->get_tx(mspi);
./spi-fsl-spi.c:		complete(&mspi->done);
./spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mspi->reg_base;
./spi-fsl-spi.c:	dev_dbg(mspi->dev, "%s: events %x\n", __func__, events);
./spi-fsl-spi.c:	if (mspi->flags & SPI_CPM_MODE)
./spi-fsl-spi.c:	iounmap(mspi->reg_base);
./spi-fsl-spi.c:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
./spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mpc8xxx_spi->reg_base;
./spi-fsl-spi.c:	u16 cs = spi->chip_select;
./spi-fsl-spi.c:	if (gpio_is_valid(spi->cs_gpio)) {
./spi-fsl-spi.c:		gpio_set_value(spi->cs_gpio, on);
./spi-fsl-spi.c:	} else if (cs < mpc8xxx_spi->native_chipselects) {
./spi-fsl-spi.c:	struct fsl_spi_reg *reg_base = mpc8xxx_spi->reg_base;
./spi-fsl-spi.c:	mpc8xxx_spi->set_shifts = fsl_spi_grlib_set_shifts;
./spi-fsl-spi.c:		mpc8xxx_spi->max_bits_per_word = mbits + 1;
./spi-fsl-spi.c:	mpc8xxx_spi->native_chipselects = 0;
./spi-fsl-spi.c:		mpc8xxx_spi->native_chipselects = SPCAP_SSSZ(capabilities);
./spi-fsl-spi.c:	master->num_chipselect = mpc8xxx_spi->native_chipselects;
./spi-fsl-spi.c:	mpc8xxx_spi->spi_remove = fsl_spi_remove;
./spi-fsl-spi.c:	mpc8xxx_spi->max_bits_per_word = 32;
./spi-fsl-spi.c:	mpc8xxx_spi->type = fsl_spi_get_type(dev);
./spi-fsl-spi.c:	mpc8xxx_spi->reg_base = ioremap(mem->start, resource_size(mem));
./spi-fsl-spi.c:	if (mpc8xxx_spi->reg_base == NULL) {
./spi-fsl-spi.c:	if (mpc8xxx_spi->type == TYPE_GRLIB)
./spi-fsl-spi.c:		SPI_BPW_RANGE_MASK(1, mpc8xxx_spi->max_bits_per_word);
./spi-fsl-spi.c:	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)
./spi-fsl-spi.c:		mpc8xxx_spi->set_shifts = fsl_spi_qe_cpu_set_shifts;
./spi-fsl-spi.c:	if (mpc8xxx_spi->set_shifts)
./spi-fsl-spi.c:		mpc8xxx_spi->set_shifts(&mpc8xxx_spi->rx_shift,
./spi-fsl-spi.c:					&mpc8xxx_spi->tx_shift, 8, 1);
./spi-fsl-spi.c:	ret = request_irq(mpc8xxx_spi->irq, fsl_spi_irq,
./spi-fsl-spi.c:	reg_base = mpc8xxx_spi->reg_base;
./spi-fsl-spi.c:	if (mpc8xxx_spi->max_bits_per_word < 8) {
./spi-fsl-spi.c:		regval |= SPMODE_LEN(mpc8xxx_spi->max_bits_per_word - 1);
./spi-fsl-spi.c:	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)
./spi-fsl-spi.c:		 mpc8xxx_spi->irq, mpc8xxx_spi_strmode(mpc8xxx_spi->flags));
./spi-fsl-spi.c:	free_irq(mpc8xxx_spi->irq, mpc8xxx_spi);
./spi-fsl-spi.c:	iounmap(mpc8xxx_spi->reg_base);
./spi-fsl-spi.c:	struct device *dev = spi->dev.parent->parent;
./spi-fsl-spi.c:	u16 cs = spi->chip_select;
./spi-fsl-spi.c:	if (mpc8xxx_spi->type == TYPE_FSL)
./spi-adi-v3.c:	drv_data->tx_dma_addr = dma_map_single(&msg->spi->dev,
./spi-adi-v3.c:	if (dma_mapping_error(&msg->spi->dev,
./spi-adi-v3.c:	drv_data->rx_dma_addr = dma_map_single(&msg->spi->dev,
./spi-adi-v3.c:	if (dma_mapping_error(&msg->spi->dev,
./spi-adi-v3.c:		dma_unmap_single(&msg->spi->dev,
./spi-adi-v3.c:	struct adi_spi_master *drv_data = spi_master_get_devdata(spi->master);
./spi-adi-v3.c:		struct adi_spi3_chip *chip_info = spi->controller_data;
./spi-adi-v3.c:				dev_err(&spi->dev,
./spi-adi-v3.c:		chip->cs = spi->chip_select;
./spi-adi-v3.c:			ret = peripheral_request(ssel[spi->master->bus_num]
./spi-adi-v3.c:					[chip->cs-1], dev_name(&spi->dev));
./spi-adi-v3.c:				dev_err(&spi->dev, "peripheral_request() error\n");
./spi-adi-v3.c:						dev_name(&spi->dev));
./spi-adi-v3.c:				dev_err(&spi->dev, "gpio_request_one() error\n");
./spi-adi-v3.c:	if (spi->mode & SPI_CPOL)
./spi-adi-v3.c:	if (spi->mode & SPI_CPHA)
./spi-adi-v3.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-adi-v3.c:	chip->clock = hz_to_spi_clock(drv_data->sclk, spi->max_speed_hz);
./spi-adi-v3.c:	struct adi_spi_master *drv_data = spi_master_get_devdata(spi->master);
./spi-adi-v3.c:		peripheral_free(ssel[spi->master->bus_num]
./spi-dw-pci.c:#include "spi-dw.h"
./spi-bfin5xx.c:	struct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
./spi-bfin5xx.c:	dev_dbg(&spi->dev, "adding an msg in transfer() \n");
./spi-bfin5xx.c:	struct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
./spi-bfin5xx.c:			dev_err(&spi->dev, "cannot allocate chip data\n");
./spi-bfin5xx.c:		chip_info = spi->controller_data;
./spi-bfin5xx.c:			dev_err(&spi->dev,
./spi-bfin5xx.c:	if (spi->mode & SPI_CPOL)
./spi-bfin5xx.c:	if (spi->mode & SPI_CPHA)
./spi-bfin5xx.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-bfin5xx.c:	chip->baud = hz_to_spi_baud(spi->max_speed_hz);
./spi-bfin5xx.c:	chip->chip_select_num = spi->chip_select;
./spi-bfin5xx.c:		if (!(spi->mode & SPI_CPHA))
./spi-bfin5xx.c:			dev_warn(&spi->dev,
./spi-bfin5xx.c:				"See Documentation/blackfin/bfin-spi-notes.txt\n");
./spi-bfin5xx.c:		chip->flag = (1 << spi->chip_select) << 8;
./spi-bfin5xx.c:		dev_err(&spi->dev,
./spi-bfin5xx.c:			dev_err(&spi->dev,
./spi-bfin5xx.c:			dev_err(&spi->dev, "Unable to set dma callback\n");
./spi-bfin5xx.c:			dev_err(&spi->dev, "Unable to register spi IRQ\n");
./spi-bfin5xx.c:			ret = gpio_request(chip->cs_gpio, spi->modalias);
./spi-bfin5xx.c:				dev_err(&spi->dev, "gpio_request() error\n");
./spi-bfin5xx.c:	dev_dbg(&spi->dev, "setup spi chip %s, width is %d, dma is %d\n",
./spi-bfin5xx.c:			spi->modalias, spi->bits_per_word, chip->enable_dma);
./spi-bfin5xx.c:	dev_dbg(&spi->dev, "ctl_reg is 0x%x, flag_reg is 0x%x\n",
./spi-bfin5xx.c:	dev_dbg(&spi->dev, "chip select number is %d\n", chip->chip_select_num);
./spi-bfin5xx.c:		ret = peripheral_request(ssel[spi->master->bus_num]
./spi-bfin5xx.c:		                         [chip->chip_select_num-1], spi->modalias);
./spi-bfin5xx.c:			dev_err(&spi->dev, "peripheral_request() error\n");
./spi-bfin5xx.c:		peripheral_free(ssel[spi->master->bus_num]
./spi-bfin5xx.c:	struct bfin_spi_master_data *drv_data = spi_master_get_devdata(spi->master);
./spi-bfin5xx.c:		peripheral_free(ssel[spi->master->bus_num]
./spi-bfin5xx.c:	/* the spi->mode bits supported by this driver: */
./spi-sh-hspi.c: * Based on spi-sh.c:
./spi-sh-hspi.c:	iowrite32(val, hspi->addr + reg);
./spi-sh-hspi.c:	return ioread32(hspi->addr + reg);
./spi-sh-hspi.c:	dev_err(hspi->dev, "timeout\n");
./spi-sh-hspi.c:	struct device *dev = hspi->dev;
./spi-sh-hspi.c:		rate = clk_get_rate(hspi->clk);
./spi-sh-hspi.c:	if (spi->mode & SPI_CPHA)
./spi-sh-hspi.c:	if (spi->mode & SPI_CPOL)
./spi-sh-hspi.c:	dev_dbg(hspi->dev, "%s\n", __func__);
./spi-sh-hspi.c:	hspi->master	= master;
./spi-sh-hspi.c:	hspi->dev	= &pdev->dev;
./spi-sh-hspi.c:	hspi->clk	= clk;
./spi-sh-hspi.c:	hspi->addr	= devm_ioremap(hspi->dev,
./spi-sh-hspi.c:	if (!hspi->addr) {
./spi-sh-hspi.c:	clk_put(hspi->clk);
./spi-ep93xx.c:#include <linux/platform_data/spi-ep93xx.h>
./spi-ep93xx.c:	writeb(value, espi->regs_base + reg);
./spi-ep93xx.c:	return readb(spi->regs_base + reg);
./spi-ep93xx.c:	writew(value, espi->regs_base + reg);
./spi-ep93xx.c:	return readw(spi->regs_base + reg);
./spi-ep93xx.c:	err = clk_enable(espi->clk);
./spi-ep93xx.c:	clk_disable(espi->clk);
./spi-ep93xx.c:	struct spi_master *master = platform_get_drvdata(espi->pdev);
./spi-ep93xx.c:	unsigned long spi_clk_rate = clk_get_rate(espi->clk);
./spi-ep93xx.c:	int value = (spi->mode & SPI_CS_HIGH) ? control : !control;
./spi-ep93xx.c:	struct ep93xx_spi *espi = spi_master_get_devdata(spi->master);
./spi-ep93xx.c:		dev_dbg(&espi->pdev->dev, "initial setup for %s\n",
./spi-ep93xx.c:			spi->modalias);
./spi-ep93xx.c:		chip->ops = spi->controller_data;
./spi-ep93xx.c:	cr0 |= (chip->spi->mode & (SPI_CPHA|SPI_CPOL)) << SSPCR0_MODE_SHIFT;
./spi-ep93xx.c:	dev_dbg(&espi->pdev->dev, "setup: mode %d, cpsr %d, scr %d, dss %d\n",
./spi-ep93xx.c:		chip->spi->mode, div_cpsr, div_scr, dss);
./spi-ep93xx.c:	dev_dbg(&espi->pdev->dev, "setup: cr0 %#x\n", cr0);
./spi-ep93xx.c:			tx_val = ((u16 *)t->tx_buf)[espi->tx];
./spi-ep93xx.c:		espi->tx += sizeof(tx_val);
./spi-ep93xx.c:			tx_val = ((u8 *)t->tx_buf)[espi->tx];
./spi-ep93xx.c:		espi->tx += sizeof(tx_val);
./spi-ep93xx.c:			((u16 *)t->rx_buf)[espi->rx] = rx_val;
./spi-ep93xx.c:		espi->rx += sizeof(rx_val);
./spi-ep93xx.c:			((u8 *)t->rx_buf)[espi->rx] = rx_val;
./spi-ep93xx.c:		espi->rx += sizeof(rx_val);
./spi-ep93xx.c:	struct spi_message *msg = espi->current_msg;
./spi-ep93xx.c:		espi->fifo_level--;
./spi-ep93xx.c:	while (espi->fifo_level < SPI_FIFO_SIZE && espi->tx < t->len) {
./spi-ep93xx.c:		espi->fifo_level++;
./spi-ep93xx.c:	if (espi->rx == t->len)
./spi-ep93xx.c:		wait_for_completion(&espi->wait);
./spi-ep93xx.c:	struct spi_transfer *t = espi->current_msg->state;
./spi-ep93xx.c:		chan = espi->dma_rx;
./spi-ep93xx.c:		sgt = &espi->rx_sgt;
./spi-ep93xx.c:		conf.src_addr = espi->sspdr_phys;
./spi-ep93xx.c:		chan = espi->dma_tx;
./spi-ep93xx.c:		sgt = &espi->tx_sgt;
./spi-ep93xx.c:		conf.dst_addr = espi->sspdr_phys;
./spi-ep93xx.c:	 * because we are using @espi->zeropage to provide a zero RX buffer
./spi-ep93xx.c:			sg_set_page(sg, virt_to_page(espi->zeropage),
./spi-ep93xx.c:		dev_warn(&espi->pdev->dev, "len = %zu expected 0!\n", len);
./spi-ep93xx.c:		chan = espi->dma_rx;
./spi-ep93xx.c:		sgt = &espi->rx_sgt;
./spi-ep93xx.c:		chan = espi->dma_tx;
./spi-ep93xx.c:		sgt = &espi->tx_sgt;
./spi-ep93xx.c:	struct spi_message *msg = espi->current_msg;
./spi-ep93xx.c:		dev_err(&espi->pdev->dev, "DMA RX failed: %ld\n", PTR_ERR(rxd));
./spi-ep93xx.c:		dev_err(&espi->pdev->dev, "DMA TX failed: %ld\n", PTR_ERR(rxd));
./spi-ep93xx.c:	rxd->callback_param = &espi->wait;
./spi-ep93xx.c:	dma_async_issue_pending(espi->dma_rx);
./spi-ep93xx.c:	dma_async_issue_pending(espi->dma_tx);
./spi-ep93xx.c:	wait_for_completion(&espi->wait);
./spi-ep93xx.c:		dev_err(&espi->pdev->dev,
./spi-ep93xx.c:	espi->rx = 0;
./spi-ep93xx.c:	espi->tx = 0;
./spi-ep93xx.c:	if (espi->dma_rx && t->len > SPI_FIFO_SIZE)
./spi-ep93xx.c:		dev_err(&espi->pdev->dev, "failed to enable SPI controller\n");
./spi-ep93xx.c:			dev_warn(&espi->pdev->dev,
./spi-ep93xx.c:	espi->fifo_level = 0;
./spi-ep93xx.c:	espi->current_msg = msg;
./spi-ep93xx.c:	espi->current_msg = NULL;
./spi-ep93xx.c:		dev_warn(&espi->pdev->dev,
./spi-ep93xx.c:		espi->current_msg->status = -EIO;
./spi-ep93xx.c:	complete(&espi->wait);
./spi-ep93xx.c:	espi->zeropage = (void *)get_zeroed_page(GFP_KERNEL);
./spi-ep93xx.c:	if (!espi->zeropage)
./spi-ep93xx.c:	espi->dma_rx_data.port = EP93XX_DMA_SSP;
./spi-ep93xx.c:	espi->dma_rx_data.direction = DMA_DEV_TO_MEM;
./spi-ep93xx.c:	espi->dma_rx_data.name = "ep93xx-spi-rx";
./spi-ep93xx.c:	espi->dma_rx = dma_request_channel(mask, ep93xx_spi_dma_filter,
./spi-ep93xx.c:					   &espi->dma_rx_data);
./spi-ep93xx.c:	if (!espi->dma_rx) {
./spi-ep93xx.c:	espi->dma_tx_data.port = EP93XX_DMA_SSP;
./spi-ep93xx.c:	espi->dma_tx_data.direction = DMA_MEM_TO_DEV;
./spi-ep93xx.c:	espi->dma_tx_data.name = "ep93xx-spi-tx";
./spi-ep93xx.c:	espi->dma_tx = dma_request_channel(mask, ep93xx_spi_dma_filter,
./spi-ep93xx.c:					   &espi->dma_tx_data);
./spi-ep93xx.c:	if (!espi->dma_tx) {
./spi-ep93xx.c:	dma_release_channel(espi->dma_rx);
./spi-ep93xx.c:	espi->dma_rx = NULL;
./spi-ep93xx.c:	free_page((unsigned long)espi->zeropage);
./spi-ep93xx.c:	if (espi->dma_rx) {
./spi-ep93xx.c:		dma_release_channel(espi->dma_rx);
./spi-ep93xx.c:		sg_free_table(&espi->rx_sgt);
./spi-ep93xx.c:	if (espi->dma_tx) {
./spi-ep93xx.c:		dma_release_channel(espi->dma_tx);
./spi-ep93xx.c:		sg_free_table(&espi->tx_sgt);
./spi-ep93xx.c:	if (espi->zeropage)
./spi-ep93xx.c:		free_page((unsigned long)espi->zeropage);
./spi-ep93xx.c:	espi->clk = devm_clk_get(&pdev->dev, NULL);
./spi-ep93xx.c:	if (IS_ERR(espi->clk)) {
./spi-ep93xx.c:		error = PTR_ERR(espi->clk);
./spi-ep93xx.c:	init_completion(&espi->wait);
./spi-ep93xx.c:	master->max_speed_hz = clk_get_rate(espi->clk) / 2;
./spi-ep93xx.c:	master->min_speed_hz = clk_get_rate(espi->clk) / (254 * 256);
./spi-ep93xx.c:	espi->pdev = pdev;
./spi-ep93xx.c:	espi->sspdr_phys = res->start + SSPDR;
./spi-ep93xx.c:	espi->regs_base = devm_ioremap_resource(&pdev->dev, res);
./spi-ep93xx.c:	if (IS_ERR(espi->regs_base)) {
./spi-ep93xx.c:		error = PTR_ERR(espi->regs_base);
./spi-pxa2xx-pxadma.c:#include "spi-pxa2xx.h"
./spi-pxa2xx-pxadma.c:	struct device *dev = &msg->spi->dev;
./spi-pxa2xx-pxadma.c:		dev = &drv_data->cur_msg->spi->dev;
./spi-pxa2xx-pxadma.c:			(struct pxa2xx_spi_chip *)spi->controller_data;
./spi-fsl-lib.c:#include "spi-fsl-lib.h"
./spi-fsl-lib.c:	type *rx = mpc8xxx_spi->rx;					  \
./spi-fsl-lib.c:	*rx++ = (type)(data >> mpc8xxx_spi->rx_shift);			  \
./spi-fsl-lib.c:	mpc8xxx_spi->rx = rx;						  \
./spi-fsl-lib.c:	const type *tx = mpc8xxx_spi->tx;			\
./spi-fsl-lib.c:	data = *tx++ << mpc8xxx_spi->tx_shift;			\
./spi-fsl-lib.c:	mpc8xxx_spi->tx = tx;					\
./spi-fsl-lib.c:	/* the spi->mode bits understood by this driver: */
./spi-fsl-lib.c:	mpc8xxx_spi->dev = dev;
./spi-fsl-lib.c:	mpc8xxx_spi->get_rx = mpc8xxx_spi_rx_buf_u8;
./spi-fsl-lib.c:	mpc8xxx_spi->get_tx = mpc8xxx_spi_tx_buf_u8;
./spi-fsl-lib.c:	mpc8xxx_spi->flags = pdata->flags;
./spi-fsl-lib.c:	mpc8xxx_spi->spibrg = pdata->sysclk;
./spi-fsl-lib.c:	mpc8xxx_spi->irq = irq;
./spi-fsl-lib.c:	mpc8xxx_spi->rx_shift = 0;
./spi-fsl-lib.c:	mpc8xxx_spi->tx_shift = 0;
./spi-fsl-lib.c:	init_completion(&mpc8xxx_spi->done);
./spi-fsl-lib.c:	free_irq(mpc8xxx_spi->irq, mpc8xxx_spi);
./spi-fsl-lib.c:	if (mpc8xxx_spi->spi_remove)
./spi-fsl-lib.c:		mpc8xxx_spi->spi_remove(mpc8xxx_spi);
./spi-tegra20-slink.c:	return readl(tspi->base + reg);
./spi-tegra20-slink.c:	writel(val, tspi->base + reg);
./spi-tegra20-slink.c:		readl(tspi->base + SLINK_MAS_DATA);
./spi-tegra20-slink.c:	switch (tspi->bytes_per_word) {
./spi-tegra20-slink.c:	unsigned remain_len = t->len - tspi->cur_pos;
./spi-tegra20-slink.c:	tspi->bytes_per_word = DIV_ROUND_UP(bits_per_word, 8);
./spi-tegra20-slink.c:		tspi->is_packed = 1;
./spi-tegra20-slink.c:		tspi->words_per_32bit = 32/bits_per_word;
./spi-tegra20-slink.c:		tspi->is_packed = 0;
./spi-tegra20-slink.c:		tspi->words_per_32bit = 1;
./spi-tegra20-slink.c:	tspi->packed_size = tegra_slink_get_packed_size(tspi, t);
./spi-tegra20-slink.c:	if (tspi->is_packed) {
./spi-tegra20-slink.c:		max_len = min(remain_len, tspi->max_buf_size);
./spi-tegra20-slink.c:		tspi->curr_dma_words = max_len/tspi->bytes_per_word;
./spi-tegra20-slink.c:		max_word = (remain_len - 1) / tspi->bytes_per_word + 1;
./spi-tegra20-slink.c:		max_word = min(max_word, tspi->max_buf_size/4);
./spi-tegra20-slink.c:		tspi->curr_dma_words = max_word;
./spi-tegra20-slink.c:	u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
./spi-tegra20-slink.c:	if (tspi->is_packed) {
./spi-tegra20-slink.c:		fifo_words_left = tx_empty_count * tspi->words_per_32bit;
./spi-tegra20-slink.c:		written_words = min(fifo_words_left, tspi->curr_dma_words);
./spi-tegra20-slink.c:		nbytes = written_words * tspi->bytes_per_word;
./spi-tegra20-slink.c:		max_n_32bit = min(tspi->curr_dma_words,  tx_empty_count);
./spi-tegra20-slink.c:		nbytes = written_words * tspi->bytes_per_word;
./spi-tegra20-slink.c:			for (i = 0; nbytes && (i < tspi->bytes_per_word);
./spi-tegra20-slink.c:	tspi->cur_tx_pos += written_words * tspi->bytes_per_word;
./spi-tegra20-slink.c:	u8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_rx_pos;
./spi-tegra20-slink.c:	if (tspi->is_packed) {
./spi-tegra20-slink.c:		len = tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra20-slink.c:		tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra20-slink.c:		read_words += tspi->curr_dma_words;
./spi-tegra20-slink.c:			for (i = 0; (i < tspi->bytes_per_word); i++)
./spi-tegra20-slink.c:		tspi->cur_rx_pos += rx_full_count * tspi->bytes_per_word;
./spi-tegra20-slink.c:	dma_sync_single_for_cpu(tspi->dev, tspi->tx_dma_phys,
./spi-tegra20-slink.c:				tspi->dma_buf_size, DMA_TO_DEVICE);
./spi-tegra20-slink.c:	if (tspi->is_packed) {
./spi-tegra20-slink.c:		unsigned len = tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra20-slink.c:		memcpy(tspi->tx_dma_buf, t->tx_buf + tspi->cur_pos, len);
./spi-tegra20-slink.c:		u8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;
./spi-tegra20-slink.c:		unsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra20-slink.c:		for (count = 0; count < tspi->curr_dma_words; count++) {
./spi-tegra20-slink.c:			for (i = 0; consume && (i < tspi->bytes_per_word);
./spi-tegra20-slink.c:			tspi->tx_dma_buf[count] = x;
./spi-tegra20-slink.c:	tspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra20-slink.c:	dma_sync_single_for_device(tspi->dev, tspi->tx_dma_phys,
./spi-tegra20-slink.c:				tspi->dma_buf_size, DMA_TO_DEVICE);
./spi-tegra20-slink.c:	dma_sync_single_for_cpu(tspi->dev, tspi->rx_dma_phys,
./spi-tegra20-slink.c:		tspi->dma_buf_size, DMA_FROM_DEVICE);
./spi-tegra20-slink.c:	if (tspi->is_packed) {
./spi-tegra20-slink.c:		len = tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra20-slink.c:		memcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_dma_buf, len);
./spi-tegra20-slink.c:		unsigned char *rx_buf = t->rx_buf + tspi->cur_rx_pos;
./spi-tegra20-slink.c:		for (count = 0; count < tspi->curr_dma_words; count++) {
./spi-tegra20-slink.c:			u32 x = tspi->rx_dma_buf[count] & rx_mask;
./spi-tegra20-slink.c:			for (i = 0; (i < tspi->bytes_per_word); i++)
./spi-tegra20-slink.c:	tspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;
./spi-tegra20-slink.c:	dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
./spi-tegra20-slink.c:		tspi->dma_buf_size, DMA_FROM_DEVICE);
./spi-tegra20-slink.c:	reinit_completion(&tspi->tx_dma_complete);
./spi-tegra20-slink.c:	tspi->tx_dma_desc = dmaengine_prep_slave_single(tspi->tx_dma_chan,
./spi-tegra20-slink.c:				tspi->tx_dma_phys, len, DMA_MEM_TO_DEV,
./spi-tegra20-slink.c:	if (!tspi->tx_dma_desc) {
./spi-tegra20-slink.c:		dev_err(tspi->dev, "Not able to get desc for Tx\n");
./spi-tegra20-slink.c:	tspi->tx_dma_desc->callback = tegra_slink_dma_complete;
./spi-tegra20-slink.c:	tspi->tx_dma_desc->callback_param = &tspi->tx_dma_complete;
./spi-tegra20-slink.c:	dmaengine_submit(tspi->tx_dma_desc);
./spi-tegra20-slink.c:	dma_async_issue_pending(tspi->tx_dma_chan);
./spi-tegra20-slink.c:	reinit_completion(&tspi->rx_dma_complete);
./spi-tegra20-slink.c:	tspi->rx_dma_desc = dmaengine_prep_slave_single(tspi->rx_dma_chan,
./spi-tegra20-slink.c:				tspi->rx_dma_phys, len, DMA_DEV_TO_MEM,
./spi-tegra20-slink.c:	if (!tspi->rx_dma_desc) {
./spi-tegra20-slink.c:		dev_err(tspi->dev, "Not able to get desc for Rx\n");
./spi-tegra20-slink.c:	tspi->rx_dma_desc->callback = tegra_slink_dma_complete;
./spi-tegra20-slink.c:	tspi->rx_dma_desc->callback_param = &tspi->rx_dma_complete;
./spi-tegra20-slink.c:	dmaengine_submit(tspi->rx_dma_desc);
./spi-tegra20-slink.c:	dma_async_issue_pending(tspi->rx_dma_chan);
./spi-tegra20-slink.c:		dev_err(tspi->dev, "Rx/Tx fifo are not empty status 0x%08x\n",
./spi-tegra20-slink.c:	val = SLINK_DMA_BLOCK_SIZE(tspi->curr_dma_words - 1);
./spi-tegra20-slink.c:	val |= tspi->packed_size;
./spi-tegra20-slink.c:	if (tspi->is_packed)
./spi-tegra20-slink.c:		len = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,
./spi-tegra20-slink.c:		len = tspi->curr_dma_words * 4;
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX)
./spi-tegra20-slink.c:	tspi->dma_control_reg = val;
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX) {
./spi-tegra20-slink.c:			dev_err(tspi->dev,
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX) {
./spi-tegra20-slink.c:		dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
./spi-tegra20-slink.c:				tspi->dma_buf_size, DMA_FROM_DEVICE);
./spi-tegra20-slink.c:			dev_err(tspi->dev,
./spi-tegra20-slink.c:			if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra20-slink.c:				dmaengine_terminate_all(tspi->tx_dma_chan);
./spi-tegra20-slink.c:	tspi->is_curr_dma_xfer = true;
./spi-tegra20-slink.c:	if (tspi->is_packed) {
./spi-tegra20-slink.c:	tspi->dma_control_reg = val;
./spi-tegra20-slink.c:	val = tspi->packed_size;
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX)
./spi-tegra20-slink.c:	tspi->dma_control_reg = val;
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra20-slink.c:		cur_words = tspi->curr_dma_words;
./spi-tegra20-slink.c:	tspi->dma_control_reg = val;
./spi-tegra20-slink.c:	tspi->is_curr_dma_xfer = false;
./spi-tegra20-slink.c:	if (tspi->is_packed) {
./spi-tegra20-slink.c:	tspi->dma_control_reg = val;
./spi-tegra20-slink.c:	dma_chan = dma_request_slave_channel_reason(tspi->dev,
./spi-tegra20-slink.c:			dev_err(tspi->dev,
./spi-tegra20-slink.c:	dma_buf = dma_alloc_coherent(tspi->dev, tspi->dma_buf_size,
./spi-tegra20-slink.c:		dev_err(tspi->dev, " Not able to allocate the dma buffer\n");
./spi-tegra20-slink.c:		dma_sconfig.src_addr = tspi->phys + SLINK_RX_FIFO;
./spi-tegra20-slink.c:		dma_sconfig.dst_addr = tspi->phys + SLINK_TX_FIFO;
./spi-tegra20-slink.c:		tspi->rx_dma_chan = dma_chan;
./spi-tegra20-slink.c:		tspi->rx_dma_buf = dma_buf;
./spi-tegra20-slink.c:		tspi->rx_dma_phys = dma_phys;
./spi-tegra20-slink.c:		tspi->tx_dma_chan = dma_chan;
./spi-tegra20-slink.c:		tspi->tx_dma_buf = dma_buf;
./spi-tegra20-slink.c:		tspi->tx_dma_phys = dma_phys;
./spi-tegra20-slink.c:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
./spi-tegra20-slink.c:		dma_buf = tspi->rx_dma_buf;
./spi-tegra20-slink.c:		dma_chan = tspi->rx_dma_chan;
./spi-tegra20-slink.c:		dma_phys = tspi->rx_dma_phys;
./spi-tegra20-slink.c:		tspi->rx_dma_chan = NULL;
./spi-tegra20-slink.c:		tspi->rx_dma_buf = NULL;
./spi-tegra20-slink.c:		dma_buf = tspi->tx_dma_buf;
./spi-tegra20-slink.c:		dma_chan = tspi->tx_dma_chan;
./spi-tegra20-slink.c:		dma_phys = tspi->tx_dma_phys;
./spi-tegra20-slink.c:		tspi->tx_dma_buf = NULL;
./spi-tegra20-slink.c:		tspi->tx_dma_chan = NULL;
./spi-tegra20-slink.c:	dma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);
./spi-tegra20-slink.c:	struct tegra_slink_data *tspi = spi_master_get_devdata(spi->master);
./spi-tegra20-slink.c:	if (speed != tspi->cur_speed) {
./spi-tegra20-slink.c:		clk_set_rate(tspi->clk, speed * 4);
./spi-tegra20-slink.c:		tspi->cur_speed = speed;
./spi-tegra20-slink.c:	tspi->cur_spi = spi;
./spi-tegra20-slink.c:	tspi->cur_pos = 0;
./spi-tegra20-slink.c:	tspi->cur_rx_pos = 0;
./spi-tegra20-slink.c:	tspi->cur_tx_pos = 0;
./spi-tegra20-slink.c:	tspi->curr_xfer = t;
./spi-tegra20-slink.c:	command = tspi->command_reg;
./spi-tegra20-slink.c:	command2 = tspi->command2_reg;
./spi-tegra20-slink.c:	tspi->command_reg = command;
./spi-tegra20-slink.c:	tspi->cur_direction = 0;
./spi-tegra20-slink.c:		tspi->cur_direction |= DATA_DIR_RX;
./spi-tegra20-slink.c:		tspi->cur_direction |= DATA_DIR_TX;
./spi-tegra20-slink.c:	tspi->command2_reg = command2;
./spi-tegra20-slink.c:	struct tegra_slink_data *tspi = spi_master_get_devdata(spi->master);
./spi-tegra20-slink.c:	dev_dbg(&spi->dev, "setup %d bpw, %scpol, %scpha, %dHz\n",
./spi-tegra20-slink.c:		spi->bits_per_word,
./spi-tegra20-slink.c:		spi->mode & SPI_CPOL ? "" : "~",
./spi-tegra20-slink.c:		spi->mode & SPI_CPHA ? "" : "~",
./spi-tegra20-slink.c:		spi->max_speed_hz);
./spi-tegra20-slink.c:	ret = pm_runtime_get_sync(tspi->dev);
./spi-tegra20-slink.c:		dev_err(tspi->dev, "pm runtime failed, e = %d\n", ret);
./spi-tegra20-slink.c:	spin_lock_irqsave(&tspi->lock, flags);
./spi-tegra20-slink.c:	val = tspi->def_command_reg;
./spi-tegra20-slink.c:	if (spi->mode & SPI_CS_HIGH)
./spi-tegra20-slink.c:		val |= cs_pol_bit[spi->chip_select];
./spi-tegra20-slink.c:		val &= ~cs_pol_bit[spi->chip_select];
./spi-tegra20-slink.c:	tspi->def_command_reg = val;
./spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);
./spi-tegra20-slink.c:	spin_unlock_irqrestore(&tspi->lock, flags);
./spi-tegra20-slink.c:	pm_runtime_put(tspi->dev);
./spi-tegra20-slink.c:	tspi->command_reg = tspi->def_command_reg;
./spi-tegra20-slink.c:	tspi->command_reg |= SLINK_CS_SW | SLINK_CS_VALUE;
./spi-tegra20-slink.c:	tspi->command2_reg = tspi->def_command2_reg;
./spi-tegra20-slink.c:	tspi->command2_reg |= SLINK_SS_EN_CS(spi->chip_select);
./spi-tegra20-slink.c:	tspi->command_reg &= ~SLINK_MODES;
./spi-tegra20-slink.c:	if (spi->mode & SPI_CPHA)
./spi-tegra20-slink.c:		tspi->command_reg |= SLINK_CK_SDA;
./spi-tegra20-slink.c:	if (spi->mode & SPI_CPOL)
./spi-tegra20-slink.c:		tspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_HIGH;
./spi-tegra20-slink.c:		tspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_LOW;
./spi-tegra20-slink.c:	reinit_completion(&tspi->xfer_completion);
./spi-tegra20-slink.c:		dev_err(tspi->dev,
./spi-tegra20-slink.c:	ret = wait_for_completion_timeout(&tspi->xfer_completion,
./spi-tegra20-slink.c:		dev_err(tspi->dev,
./spi-tegra20-slink.c:	if (tspi->tx_status)
./spi-tegra20-slink.c:		return tspi->tx_status;
./spi-tegra20-slink.c:	if (tspi->rx_status)
./spi-tegra20-slink.c:		return tspi->rx_status;
./spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);
./spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);
./spi-tegra20-slink.c:	struct spi_transfer *t = tspi->curr_xfer;
./spi-tegra20-slink.c:	spin_lock_irqsave(&tspi->lock, flags);
./spi-tegra20-slink.c:	if (tspi->tx_status ||  tspi->rx_status ||
./spi-tegra20-slink.c:				(tspi->status_reg & SLINK_BSY)) {
./spi-tegra20-slink.c:		dev_err(tspi->dev,
./spi-tegra20-slink.c:			"CpuXfer ERROR bit set 0x%x\n", tspi->status_reg);
./spi-tegra20-slink.c:		dev_err(tspi->dev,
./spi-tegra20-slink.c:			"CpuXfer 0x%08x:0x%08x:0x%08x\n", tspi->command_reg,
./spi-tegra20-slink.c:				tspi->command2_reg, tspi->dma_control_reg);
./spi-tegra20-slink.c:		reset_control_assert(tspi->rst);
./spi-tegra20-slink.c:		reset_control_deassert(tspi->rst);
./spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX)
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra20-slink.c:		tspi->cur_pos = tspi->cur_tx_pos;
./spi-tegra20-slink.c:		tspi->cur_pos = tspi->cur_rx_pos;
./spi-tegra20-slink.c:	if (tspi->cur_pos == t->len) {
./spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
./spi-tegra20-slink.c:	tegra_slink_calculate_curr_xfer_param(tspi->cur_spi, tspi, t);
./spi-tegra20-slink.c:	spin_unlock_irqrestore(&tspi->lock, flags);
./spi-tegra20-slink.c:	struct spi_transfer *t = tspi->curr_xfer;
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX) {
./spi-tegra20-slink.c:		if (tspi->tx_status) {
./spi-tegra20-slink.c:			dmaengine_terminate_all(tspi->tx_dma_chan);
./spi-tegra20-slink.c:				&tspi->tx_dma_complete, SLINK_DMA_TIMEOUT);
./spi-tegra20-slink.c:				dmaengine_terminate_all(tspi->tx_dma_chan);
./spi-tegra20-slink.c:				dev_err(tspi->dev, "TxDma Xfer failed\n");
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX) {
./spi-tegra20-slink.c:		if (tspi->rx_status) {
./spi-tegra20-slink.c:			dmaengine_terminate_all(tspi->rx_dma_chan);
./spi-tegra20-slink.c:				&tspi->rx_dma_complete, SLINK_DMA_TIMEOUT);
./spi-tegra20-slink.c:				dmaengine_terminate_all(tspi->rx_dma_chan);
./spi-tegra20-slink.c:				dev_err(tspi->dev, "RxDma Xfer failed\n");
./spi-tegra20-slink.c:	spin_lock_irqsave(&tspi->lock, flags);
./spi-tegra20-slink.c:		dev_err(tspi->dev,
./spi-tegra20-slink.c:			"DmaXfer: ERROR bit set 0x%x\n", tspi->status_reg);
./spi-tegra20-slink.c:		dev_err(tspi->dev,
./spi-tegra20-slink.c:			"DmaXfer 0x%08x:0x%08x:0x%08x\n", tspi->command_reg,
./spi-tegra20-slink.c:				tspi->command2_reg, tspi->dma_control_reg);
./spi-tegra20-slink.c:		reset_control_assert(tspi->rst);
./spi-tegra20-slink.c:		reset_control_assert(tspi->rst);
./spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
./spi-tegra20-slink.c:		spin_unlock_irqrestore(&tspi->lock, flags);
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX)
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra20-slink.c:		tspi->cur_pos = tspi->cur_tx_pos;
./spi-tegra20-slink.c:		tspi->cur_pos = tspi->cur_rx_pos;
./spi-tegra20-slink.c:	if (tspi->cur_pos == t->len) {
./spi-tegra20-slink.c:		complete(&tspi->xfer_completion);
./spi-tegra20-slink.c:	total_fifo_words = tegra_slink_calculate_curr_xfer_param(tspi->cur_spi,
./spi-tegra20-slink.c:	spin_unlock_irqrestore(&tspi->lock, flags);
./spi-tegra20-slink.c:	if (!tspi->is_curr_dma_xfer)
./spi-tegra20-slink.c:	tspi->status_reg = tegra_slink_readl(tspi, SLINK_STATUS);
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_TX)
./spi-tegra20-slink.c:		tspi->tx_status = tspi->status_reg &
./spi-tegra20-slink.c:	if (tspi->cur_direction & DATA_DIR_RX)
./spi-tegra20-slink.c:		tspi->rx_status = tspi->status_reg &
./spi-tegra20-slink.c:	/* the spi->mode bits understood by this driver: */
./spi-tegra20-slink.c:	tspi->master = master;
./spi-tegra20-slink.c:	tspi->dev = &pdev->dev;
./spi-tegra20-slink.c:	tspi->chip_data = cdata;
./spi-tegra20-slink.c:	spin_lock_init(&tspi->lock);
./spi-tegra20-slink.c:	if (of_property_read_u32(tspi->dev->of_node, "spi-max-frequency",
./spi-tegra20-slink.c:	tspi->phys = r->start;
./spi-tegra20-slink.c:	tspi->base = devm_ioremap_resource(&pdev->dev, r);
./spi-tegra20-slink.c:	if (IS_ERR(tspi->base)) {
./spi-tegra20-slink.c:		ret = PTR_ERR(tspi->base);
./spi-tegra20-slink.c:	tspi->irq = spi_irq;
./spi-tegra20-slink.c:	ret = request_threaded_irq(tspi->irq, tegra_slink_isr,
./spi-tegra20-slink.c:					tspi->irq);
./spi-tegra20-slink.c:	tspi->clk = devm_clk_get(&pdev->dev, NULL);
./spi-tegra20-slink.c:	if (IS_ERR(tspi->clk)) {
./spi-tegra20-slink.c:		ret = PTR_ERR(tspi->clk);
./spi-tegra20-slink.c:	tspi->rst = devm_reset_control_get(&pdev->dev, "spi");
./spi-tegra20-slink.c:	if (IS_ERR(tspi->rst)) {
./spi-tegra20-slink.c:		ret = PTR_ERR(tspi->rst);
./spi-tegra20-slink.c:	tspi->max_buf_size = SLINK_FIFO_DEPTH << 2;
./spi-tegra20-slink.c:	tspi->dma_buf_size = DEFAULT_SPI_DMA_BUF_LEN;
./spi-tegra20-slink.c:	tspi->max_buf_size = tspi->dma_buf_size;
./spi-tegra20-slink.c:	init_completion(&tspi->tx_dma_complete);
./spi-tegra20-slink.c:	init_completion(&tspi->rx_dma_complete);
./spi-tegra20-slink.c:	init_completion(&tspi->xfer_completion);
./spi-tegra20-slink.c:	tspi->def_command_reg  = SLINK_M_S;
./spi-tegra20-slink.c:	tspi->def_command2_reg = SLINK_CS_ACTIVE_BETWEEN;
./spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);
./spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);
./spi-tegra20-slink.c:	free_irq(tspi->irq, tspi);
./spi-tegra20-slink.c:	if (tspi->tx_dma_chan)
./spi-tegra20-slink.c:	if (tspi->rx_dma_chan)
./spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->command_reg, SLINK_COMMAND);
./spi-tegra20-slink.c:	tegra_slink_writel(tspi, tspi->command2_reg, SLINK_COMMAND2);
./spi-tegra20-slink.c:	clk_disable_unprepare(tspi->clk);
./spi-tegra20-slink.c:	ret = clk_prepare_enable(tspi->clk);
./spi-tegra20-slink.c:		dev_err(tspi->dev, "clk_prepare failed: %d\n", ret);
./spi-tegra20-slink.c:		.name		= "spi-tegra-slink",
./spi-tegra20-slink.c:MODULE_ALIAS("platform:spi-tegra-slink");
./spi-s3c24xx.c:#include "spi-s3c24xx-fiq.h"
./spi-s3c24xx.c:	gpio_set_value(spi->pin_cs, pol);
./spi-s3c24xx.c:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
./spi-s3c24xx.c:	unsigned int cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;
./spi-s3c24xx.c:		hw->set_cs(hw->pdata, spi->chip_select, cspol^1);
./spi-s3c24xx.c:		hw->set_cs(hw->pdata, spi->chip_select, cspol);
./spi-s3c24xx.c:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
./spi-s3c24xx.c:	hz  = t ? t->speed_hz : spi->max_speed_hz;
./spi-s3c24xx.c:		hz = spi->max_speed_hz;
./spi-s3c24xx.c:	if (spi->mode != cs->mode) {
./spi-s3c24xx.c:		if (spi->mode & SPI_CPHA)
./spi-s3c24xx.c:		if (spi->mode & SPI_CPOL)
./spi-s3c24xx.c:		cs->mode = spi->mode;
./spi-s3c24xx.c:		dev_dbg(&spi->dev, "pre-scaler=%d (wanted %d, got %ld)\n",
./spi-s3c24xx.c:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
./spi-s3c24xx.c:	struct s3c24xx_spi_devstate *cs = spi->controller_state;
./spi-s3c24xx.c:		cs = devm_kzalloc(&spi->dev,
./spi-s3c24xx.c:		spi->controller_state = cs;
./spi-s3c24xx.c:	return spi->fiq_inuse;
./spi-s3c24xx.c:	/* the spi->mode bits understood by this driver: */
./spi-qup.c:	struct spi_qup *controller = spi_master_get_devdata(spi->master);
./spi-qup.c:	if (spi->mode & SPI_LOOP && xfer->len > controller->in_fifo_sz) {
./spi-qup.c:	mode = spi_qup_get_mode(spi->master, xfer);
./spi-qup.c:	if (spi->mode & SPI_CPOL)
./spi-qup.c:	if (spi->mode & SPI_LOOP)
./spi-qup.c:	if (spi->mode & SPI_CPHA)
./spi-qup.c:	 * HS_MODE improves signal stability for spi-clk high rates,
./spi-qup.c:	if ((xfer->speed_hz >= SPI_HS_MIN_RATE) && !(spi->mode & SPI_LOOP))
./spi-qup.c:	struct dma_slave_config *rx_conf = &spi->rx_conf,
./spi-qup.c:				*tx_conf = &spi->tx_conf;
./spi-qup.c:	struct device *dev = spi->dev;
./spi-qup.c:	rx_conf->src_maxburst = spi->in_blk_sz;
./spi-qup.c:	tx_conf->dst_maxburst = spi->out_blk_sz;
./spi-qup.c:	if (of_property_read_u32(dev->of_node, "spi-max-frequency", &max_freq))
./spi-qup.c:	if (of_device_is_compatible(dev->of_node, "qcom,spi-qup-v1.1.1"))
./spi-qup.c:	{ .compatible = "qcom,spi-qup-v1.1.1", },
./spi-qup.c:	{ .compatible = "qcom,spi-qup-v2.1.1", },
./spi-qup.c:	{ .compatible = "qcom,spi-qup-v2.2.1", },
./spi-mpc52xx.c:		cs = ms->message->spi->chip_select;
./spi-mpc52xx.c:	if (spi->mode & SPI_CPHA)
./spi-mpc52xx.c:	if (spi->mode & SPI_CPOL)
./spi-mpc52xx.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-mpc52xx.c:	sppr = ((ms->ipb_freq / ms->message->spi->max_speed_hz) + 1) >> 1;
./spi-mpc52xx.c:	struct mpc52xx_spi *ms = spi_master_get_devdata(spi->master);
./spi-mpc52xx.c:				  "mpc5200-spi-modf", ms);
./spi-mpc52xx.c:				  "mpc5200-spi-spif", ms);
./spi-dw-mid.c:#include "spi-dw.h"
./spi-sc18is602.c:		hw->buffer[0] = 1 << msg->spi->chip_select;
./spi-sc18is602.c:		status = sc18is602_setup_transfer(hw, t->speed_hz, spi->mode);
./spi-sc18is602.c:	struct sc18is602 *hw = spi_master_get_devdata(spi->master);
./spi-sc18is602.c:	if (hw->id == sc18is602 && spi->chip_select == 2)
./spi-efm32.c:	struct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);
./spi-efm32.c:	int value = !(spi->mode & SPI_CS_HIGH) == !(is_on == BITBANG_CS_ACTIVE);
./spi-efm32.c:	gpio_set_value(ddata->csgpio[spi->chip_select], value);
./spi-efm32.c:	struct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);
./spi-efm32.c:	unsigned bpw = t->bits_per_word ?: spi->bits_per_word;
./spi-efm32.c:	unsigned speed = t->speed_hz ?: spi->max_speed_hz;
./spi-efm32.c:			(spi->mode & SPI_CPHA ? REG_CTRL_CLKPHA : 0) |
./spi-efm32.c:			(spi->mode & SPI_CPOL ? REG_CTRL_CLKPOL : 0), REG_CTRL);
./spi-efm32.c:	struct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);
./spi-sh-msiof.c:	struct device_node	*np = spi->master->dev.of_node;
./spi-sh-msiof.c:	struct sh_msiof_spi_priv *p = spi_master_get_devdata(spi->master);
./spi-sh-msiof.c:		 * Use spi->controller_data for CS (same strategy as spi_gpio),
./spi-sh-msiof.c:		spi->cs_gpio = (uintptr_t)spi->controller_data;
./spi-sh-msiof.c:	sh_msiof_spi_set_pin_regs(p, !!(spi->mode & SPI_CPOL),
./spi-sh-msiof.c:				  !!(spi->mode & SPI_CPHA),
./spi-sh-msiof.c:				  !!(spi->mode & SPI_3WIRE),
./spi-sh-msiof.c:				  !!(spi->mode & SPI_LSB_FIRST),
./spi-sh-msiof.c:				  !!(spi->mode & SPI_CS_HIGH));
./spi-sh-msiof.c:	if (spi->cs_gpio >= 0)
./spi-sh-msiof.c:		gpio_set_value(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));
./spi-sh-msiof.c:	sh_msiof_spi_set_pin_regs(p, !!(spi->mode & SPI_CPOL),
./spi-sh-msiof.c:				  !!(spi->mode & SPI_CPHA),
./spi-sh-msiof.c:				  !!(spi->mode & SPI_3WIRE),
./spi-sh-msiof.c:				  !!(spi->mode & SPI_LSB_FIRST),
./spi-sh-msiof.c:				  !!(spi->mode & SPI_CS_HIGH));
./spi-xilinx.c:	if (!xspi->tx_ptr) {
./spi-xilinx.c:		xspi->write_fn(0, xspi->regs + XSPI_TXD_OFFSET);
./spi-xilinx.c:	switch (xspi->bytes_per_word) {
./spi-xilinx.c:		data = *(u8 *)(xspi->tx_ptr);
./spi-xilinx.c:		data = *(u16 *)(xspi->tx_ptr);
./spi-xilinx.c:		data = *(u32 *)(xspi->tx_ptr);
./spi-xilinx.c:	xspi->write_fn(data, xspi->regs + XSPI_TXD_OFFSET);
./spi-xilinx.c:	xspi->tx_ptr += xspi->bytes_per_word;
./spi-xilinx.c:	u32 data = xspi->read_fn(xspi->regs + XSPI_RXD_OFFSET);
./spi-xilinx.c:	if (!xspi->rx_ptr)
./spi-xilinx.c:	switch (xspi->bytes_per_word) {
./spi-xilinx.c:		*(u8 *)(xspi->rx_ptr) = data;
./spi-xilinx.c:		*(u16 *)(xspi->rx_ptr) = data;
./spi-xilinx.c:		*(u32 *)(xspi->rx_ptr) = data;
./spi-xilinx.c:	xspi->rx_ptr += xspi->bytes_per_word;
./spi-xilinx.c:	void __iomem *regs_base = xspi->regs;
./spi-xilinx.c:	xspi->write_fn(XIPIF_V123B_RESET_MASK,
./spi-xilinx.c:	xspi->write_fn(XSPI_INTR_TX_EMPTY,
./spi-xilinx.c:	xspi->write_fn(0, regs_base + XIPIF_V123B_DGIER_OFFSET);
./spi-xilinx.c:	xspi->write_fn(0xffff, regs_base + XSPI_SSR_OFFSET);
./spi-xilinx.c:	xspi->write_fn(XSPI_CR_MANUAL_SSELECT |	XSPI_CR_MASTER_MODE |
./spi-xilinx.c:	struct xilinx_spi *xspi = spi_master_get_devdata(spi->master);
./spi-xilinx.c:		xspi->write_fn(xspi->cs_inactive, xspi->regs + XSPI_SSR_OFFSET);
./spi-xilinx.c:	cr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET)	& ~XSPI_CR_MODE_MASK;
./spi-xilinx.c:	if (spi->mode & SPI_CPHA)
./spi-xilinx.c:	if (spi->mode & SPI_CPOL)
./spi-xilinx.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-xilinx.c:	if (spi->mode & SPI_LOOP)
./spi-xilinx.c:	xspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);
./spi-xilinx.c:	/* We do not check spi->max_speed_hz here as the SPI clock
./spi-xilinx.c:	cs = xspi->cs_inactive;
./spi-xilinx.c:	cs ^= BIT(spi->chip_select);
./spi-xilinx.c:	xspi->write_fn(cs, xspi->regs + XSPI_SSR_OFFSET);
./spi-xilinx.c:	struct xilinx_spi *xspi = spi_master_get_devdata(spi->master);
./spi-xilinx.c:	if (spi->mode & SPI_CS_HIGH)
./spi-xilinx.c:		xspi->cs_inactive &= ~BIT(spi->chip_select);
./spi-xilinx.c:		xspi->cs_inactive |= BIT(spi->chip_select);
./spi-xilinx.c:	struct xilinx_spi *xspi = spi_master_get_devdata(spi->master);
./spi-xilinx.c:	xspi->tx_ptr = t->tx_buf;
./spi-xilinx.c:	xspi->rx_ptr = t->rx_buf;
./spi-xilinx.c:	remaining_words = t->len / xspi->bytes_per_word;
./spi-xilinx.c:	if (xspi->irq >= 0 &&  remaining_words > xspi->buffer_size) {
./spi-xilinx.c:		cr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET);
./spi-xilinx.c:		xspi->write_fn(cr | XSPI_CR_TRANS_INHIBIT,
./spi-xilinx.c:			       xspi->regs + XSPI_CR_OFFSET);
./spi-xilinx.c:		isr = xspi->read_fn(xspi->regs + XIPIF_V123B_IISR_OFFSET);
./spi-xilinx.c:			xspi->write_fn(isr,
./spi-xilinx.c:				       xspi->regs + XIPIF_V123B_IISR_OFFSET);
./spi-xilinx.c:		xspi->write_fn(XIPIF_V123B_GINTR_ENABLE,
./spi-xilinx.c:				xspi->regs + XIPIF_V123B_DGIER_OFFSET);
./spi-xilinx.c:		reinit_completion(&xspi->done);
./spi-xilinx.c:		n_words = min(remaining_words, xspi->buffer_size);
./spi-xilinx.c:			xspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);
./spi-xilinx.c:			wait_for_completion(&xspi->done);
./spi-xilinx.c:			while (!(xspi->read_fn(xspi->regs + XSPI_SR_OFFSET) &
./spi-xilinx.c:			xspi->write_fn(cr | XSPI_CR_TRANS_INHIBIT,
./spi-xilinx.c:			       xspi->regs + XSPI_CR_OFFSET);
./spi-xilinx.c:		xspi->write_fn(0, xspi->regs + XIPIF_V123B_DGIER_OFFSET);
./spi-xilinx.c:		xspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);
./spi-xilinx.c:	ipif_isr = xspi->read_fn(xspi->regs + XIPIF_V123B_IISR_OFFSET);
./spi-xilinx.c:	xspi->write_fn(ipif_isr, xspi->regs + XIPIF_V123B_IISR_OFFSET);
./spi-xilinx.c:		complete(&xspi->done);
./spi-xilinx.c:	xspi->write_fn(XIPIF_V123B_RESET_MASK,
./spi-xilinx.c:		xspi->regs + XIPIF_V123B_RESETR_OFFSET);
./spi-xilinx.c:		xspi->write_fn(0, xspi->regs + XSPI_TXD_OFFSET);
./spi-xilinx.c:		sr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);
./spi-xilinx.c:	{ .compatible = "xlnx,xps-spi-2.00.a", },
./spi-xilinx.c:	{ .compatible = "xlnx,xps-spi-2.00.b", },
./spi-xilinx.c:	/* the spi->mode bits understood by this driver: */
./spi-xilinx.c:	xspi->cs_inactive = 0xffffffff;
./spi-xilinx.c:	xspi->bitbang.master = master;
./spi-xilinx.c:	xspi->bitbang.chipselect = xilinx_spi_chipselect;
./spi-xilinx.c:	xspi->bitbang.setup_transfer = xilinx_spi_setup_transfer;
./spi-xilinx.c:	xspi->bitbang.txrx_bufs = xilinx_spi_txrx_bufs;
./spi-xilinx.c:	init_completion(&xspi->done);
./spi-xilinx.c:	xspi->regs = devm_ioremap_resource(&pdev->dev, res);
./spi-xilinx.c:	if (IS_ERR(xspi->regs)) {
./spi-xilinx.c:		ret = PTR_ERR(xspi->regs);
./spi-xilinx.c:	xspi->read_fn = xspi_read32;
./spi-xilinx.c:	xspi->write_fn = xspi_write32;
./spi-xilinx.c:	xspi->write_fn(XSPI_CR_LOOP, xspi->regs + XSPI_CR_OFFSET);
./spi-xilinx.c:	tmp = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET);
./spi-xilinx.c:		xspi->read_fn = xspi_read32_be;
./spi-xilinx.c:		xspi->write_fn = xspi_write32_be;
./spi-xilinx.c:	xspi->bytes_per_word = bits_per_word / 8;
./spi-xilinx.c:	xspi->buffer_size = xilinx_spi_find_buffer_size(xspi);
./spi-xilinx.c:	xspi->irq = platform_get_irq(pdev, 0);
./spi-xilinx.c:	if (xspi->irq >= 0) {
./spi-xilinx.c:		ret = devm_request_irq(&pdev->dev, xspi->irq, xilinx_spi_irq, 0,
./spi-xilinx.c:	ret = spi_bitbang_start(&xspi->bitbang);
./spi-xilinx.c:		(unsigned long long)res->start, xspi->regs, xspi->irq);
./spi-xilinx.c:	void __iomem *regs_base = xspi->regs;
./spi-xilinx.c:	spi_bitbang_stop(&xspi->bitbang);
./spi-xilinx.c:	xspi->write_fn(0, regs_base + XIPIF_V123B_IIER_OFFSET);
./spi-xilinx.c:	xspi->write_fn(0, regs_base + XIPIF_V123B_DGIER_OFFSET);
./spi-xilinx.c:	spi_master_put(xspi->bitbang.master);
./spidev.c:		dev_dbg(&spidev->spi->dev,
./spidev.c:			u_tmp->bits_per_word ? : spidev->spi->bits_per_word,
./spidev.c:			u_tmp->speed_hz ? : spidev->spi->max_speed_hz);
./spidev.c:		retval = __put_user(spi->mode & SPI_MODE_MASK,
./spidev.c:		retval = __put_user(spi->mode & SPI_MODE_MASK,
./spidev.c:		retval = __put_user((spi->mode & SPI_LSB_FIRST) ?  1 : 0,
./spidev.c:		retval = __put_user(spi->bits_per_word, (__u8 __user *)arg);
./spidev.c:			u32	save = spi->mode;
./spidev.c:			tmp |= spi->mode & ~SPI_MODE_MASK;
./spidev.c:			spi->mode = (u16)tmp;
./spidev.c:				spi->mode = save;
./spidev.c:				dev_dbg(&spi->dev, "spi mode %x\n", tmp);
./spidev.c:			u32	save = spi->mode;
./spidev.c:				spi->mode |= SPI_LSB_FIRST;
./spidev.c:				spi->mode &= ~SPI_LSB_FIRST;
./spidev.c:				spi->mode = save;
./spidev.c:				dev_dbg(&spi->dev, "%csb first\n",
./spidev.c:			u8	save = spi->bits_per_word;
./spidev.c:			spi->bits_per_word = tmp;
./spidev.c:				spi->bits_per_word = save;
./spidev.c:				dev_dbg(&spi->dev, "%d bits per word\n", tmp);
./spidev.c:			u32	save = spi->max_speed_hz;
./spidev.c:			spi->max_speed_hz = tmp;
./spidev.c:				dev_dbg(&spi->dev, "%d Hz (max)\n", tmp);
./spidev.c:			spi->max_speed_hz = save;
./spidev.c:				dev_dbg(&spidev->spi->dev, "open/ENOMEM\n");
./spidev.c:			dev_dbg(&spidev->spi->dev, "open/ENOMEM\n");
./spidev.c:			spidev->speed_hz = spidev->spi->max_speed_hz;
./spidev.c:	if (spi->dev.of_node && !of_match_device(spidev_dt_ids, &spi->dev)) {
./spidev.c:		dev_err(&spi->dev, "buggy DT: spidev listed directly in DT\n");
./spidev.c:		WARN_ON(spi->dev.of_node &&
./spidev.c:			!of_match_device(spidev_dt_ids, &spi->dev));
./spidev.c:		dev = device_create(spidev_class, &spi->dev, spidev->devt,
./spidev.c:				    spi->master->bus_num, spi->chip_select);
./spidev.c:		dev_dbg(&spi->dev, "no minor number available!\n");
./spidev.c:	spidev->speed_hz = spi->max_speed_hz;
./spi-s3c24xx-fiq.S:#include "spi-s3c24xx-fiq.h"
./spi-ppc4xx.c:	dev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n",
./spi-ppc4xx.c:	hw = spi_master_get_devdata(spi->master);
./spi-ppc4xx.c:	struct ppc4xx_spi *hw = spi_master_get_devdata(spi->master);
./spi-ppc4xx.c:	struct spi_ppc4xx_cs *cs = spi->controller_state;
./spi-ppc4xx.c:	bits_per_word = spi->bits_per_word;
./spi-ppc4xx.c:	speed = spi->max_speed_hz;
./spi-ppc4xx.c:			speed = min(t->speed_hz, spi->max_speed_hz);
./spi-ppc4xx.c:	if (!speed || (speed > spi->max_speed_hz)) {
./spi-ppc4xx.c:		dev_err(&spi->dev, "invalid speed_hz (%d)\n", speed);
./spi-ppc4xx.c:	dev_dbg(&spi->dev, "setting pre-scaler to %d (hz %d)\n", cdm, speed);
./spi-ppc4xx.c:	struct spi_ppc4xx_cs *cs = spi->controller_state;
./spi-ppc4xx.c:	if (!spi->max_speed_hz) {
./spi-ppc4xx.c:		dev_err(&spi->dev, "invalid max_speed_hz (must be non-zero)\n");
./spi-ppc4xx.c:		spi->controller_state = cs;
./spi-ppc4xx.c:	switch (spi->mode & (SPI_CPHA | SPI_CPOL)) {
./spi-ppc4xx.c:	if (spi->mode & SPI_LSB_FIRST)
./spi-ppc4xx.c:	struct ppc4xx_spi *hw = spi_master_get_devdata(spi->master);
./spi-ppc4xx.c:	unsigned int cs = spi->chip_select;
./spi-ppc4xx.c:	cspol = spi->mode & SPI_CS_HIGH ? 1 : 0;
./spi-ppc4xx.c:	kfree(spi->controller_state);
./spi-ppc4xx.c:	/* the spi->mode bits understood by this driver: */
./spi-txx9.c:	int val = (spi->mode & SPI_CS_HIGH) ? on : !on;
./spi-txx9.c:		c->last_chipselect = spi->chip_select;
./spi-txx9.c:	gpio_set_value(spi->chip_select, val);
./spi-txx9.c:	struct txx9spi *c = spi_master_get_devdata(spi->master);
./spi-txx9.c:	if (!spi->max_speed_hz)
./spi-txx9.c:	if (gpio_direction_output(spi->chip_select,
./spi-txx9.c:			!(spi->mode & SPI_CS_HIGH))) {
./spi-txx9.c:		dev_err(&spi->dev, "Cannot setup GPIO for chipselect.\n");
./spi-txx9.c:	txx9spi_cs_func(spi, c, 0, (NSEC_PER_SEC / 2) / spi->max_speed_hz);
./spi-txx9.c:	cs_delay = 100 + (NSEC_PER_SEC / 2) / spi->max_speed_hz;
./spi-txx9.c:		dev_err(&spi->dev, "Bad mode.\n");
./spi-txx9.c:			| ((spi->mode & SPI_CPOL) ? TXx9_SPCR0_SPOL : 0)
./spi-txx9.c:			| ((spi->mode & SPI_CPHA) ? TXx9_SPCR0_SPHA : 0)
./spi-txx9.c:		u32 speed_hz = t->speed_hz ? : spi->max_speed_hz;
./spi-txx9.c:	struct spi_master *master = spi->master;
./spi-txx9.c:	c->clk = devm_clk_get(&dev->dev, "spi-baseclk");
./spi-txx9.c:	/* the spi->mode bits understood by this driver: */
./spi-img-spfi.c:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
./spi-img-spfi.c:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
./spi-img-spfi.c:	if (msg->spi->mode & SPI_CPHA)
./spi-img-spfi.c:		val |= SPFI_PORT_STATE_CK_PHASE(msg->spi->chip_select);
./spi-img-spfi.c:		val &= ~SPFI_PORT_STATE_CK_PHASE(msg->spi->chip_select);
./spi-img-spfi.c:	if (msg->spi->mode & SPI_CPOL)
./spi-img-spfi.c:		val |= SPFI_PORT_STATE_CK_POL(msg->spi->chip_select);
./spi-img-spfi.c:		val &= ~SPFI_PORT_STATE_CK_POL(msg->spi->chip_select);
./spi-img-spfi.c:		ret = gpio_request_one(spi->cs_gpio,
./spi-img-spfi.c:				       (spi->mode & SPI_CS_HIGH) ?
./spi-img-spfi.c:				       dev_name(&spi->dev));
./spi-img-spfi.c:			dev_err(&spi->dev, "can't request chipselect gpio %d\n",
./spi-img-spfi.c:				spi->cs_gpio);
./spi-img-spfi.c:		if (gpio_is_valid(spi->cs_gpio)) {
./spi-img-spfi.c:			int mode = ((spi->mode & SPI_CS_HIGH) ?
./spi-img-spfi.c:			ret = gpio_direction_output(spi->cs_gpio, mode);
./spi-img-spfi.c:				dev_err(&spi->dev, "chipselect gpio %d setup failed (%d)\n",
./spi-img-spfi.c:					spi->cs_gpio, ret);
./spi-img-spfi.c:			gpio_free(spi->cs_gpio);
./spi-img-spfi.c:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
./spi-img-spfi.c:	val = spfi_readl(spfi, SPFI_DEVICE_PARAMETER(spi->chip_select));
./spi-img-spfi.c:	spfi_writel(spfi, val, SPFI_DEVICE_PARAMETER(spi->chip_select));
./spi-img-spfi.c:	struct img_spfi *spfi = spi_master_get_devdata(spi->master);
./spi-butterfly.c:	return spi->controller_data;
./spi-butterfly.c:		setsck(spi, spi->mode & SPI_CPOL);
./spi-butterfly.c:#include "spi-bitbang-txrx.h"
./spi-fsl-cpm.h:#include "spi-fsl-lib.h"
./spi-bcm63xx.c:	struct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);
./spi-bcm63xx.c:	dev_dbg(&spi->dev, "Setting clock register to %02x (hz %d)\n",
./spi-bcm63xx.c:/* the spi->mode bits understood by this driver: */
./spi-bcm63xx.c:	struct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);
./spi-bcm63xx.c:	dev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n",
./spi-bcm63xx.c:	cmd |= (spi->chip_select << SPI_CMD_DEVICE_ID_SHIFT);
./spi-bcm63xx.c:			dev_err(&spi->dev, "unable to do transfers larger than FIFO size (%i > %i)\n",
./spi-bcm63xx.c:			dev_err(&spi->dev, "unable to change speed between transfers\n");
./spi-bcm63xx.c:			dev_err(&spi->dev, "unable to keep CS asserted after transfer\n");
./spi-sh-sci.c:#include "spi-bitbang-txrx.h"
./spi-bcm53xx.c:#include "spi-bcm53xx.h"
./spi-bcm53xx.c:	return bcma_read32(b53spi->core, offset);
./spi-bcm53xx.c:	bcma_write32(b53spi->core, offset, value);
./spi-bcm53xx.c:	b53spi->read_offset = len;
./spi-bcm53xx.c:	for (i = 0; i < b53spi->read_offset + len; i++) {
./spi-bcm53xx.c:		if (!cont && i == b53spi->read_offset + len - 1)
./spi-bcm53xx.c:			 b53spi->read_offset + len - 1);
./spi-bcm53xx.c:		int offset = b53spi->read_offset + i;
./spi-bcm53xx.c:	b53spi->read_offset = 0;
./spi-bcm53xx.c:			size_t to_read = min_t(size_t, 16 - b53spi->read_offset,
./spi-bcm53xx.c:	b53spi->master = master;
./spi-bcm53xx.c:	b53spi->core = core;
./spi-bcm53xx.c:	spi_unregister_master(b53spi->master);
./spi-dw-mmio.c:#include "spi-dw.h"
./spi.c:	if (spi->master->cleanup)
./spi.c:		spi->master->cleanup(spi);
./spi.c:	spi_master_put(spi->master);
./spi.c:	return sprintf(buf, "%s%s\n", SPI_MODULE_PREFIX, spi->modalias);
./spi.c:	return strcmp(spi->modalias, drv->name) == 0;
./spi.c:	add_uevent_var(env, "MODALIAS=%s%s", SPI_MODULE_PREFIX, spi->modalias);
./spi.c:	spi->master = master;
./spi.c:	spi->dev.parent = &master->dev;
./spi.c:	spi->dev.bus = &spi_bus_type;
./spi.c:	spi->dev.release = spidev_release;
./spi.c:	spi->cs_gpio = -ENOENT;
./spi.c:	device_initialize(&spi->dev);
./spi.c:	struct acpi_device *adev = ACPI_COMPANION(&spi->dev);
./spi.c:		dev_set_name(&spi->dev, "spi-%s", acpi_dev_name(adev));
./spi.c:	dev_set_name(&spi->dev, "%s.%u", dev_name(&spi->master->dev),
./spi.c:		     spi->chip_select);
./spi.c:	if (spi->master == new_spi->master &&
./spi.c:	    spi->chip_select == new_spi->chip_select)
./spi.c:	struct spi_master *master = spi->master;
./spi.c:	if (spi->chip_select >= master->num_chipselect) {
./spi.c:			spi->chip_select,
./spi.c:				spi->chip_select);
./spi.c:		spi->cs_gpio = master->cs_gpios[spi->chip_select];
./spi.c:				dev_name(&spi->dev), status);
./spi.c:	status = device_add(&spi->dev);
./spi.c:				dev_name(&spi->dev), status);
./spi.c:		dev_dbg(dev, "registered child %s\n", dev_name(&spi->dev));
./spi.c:	if (spi->mode & SPI_CS_HIGH)
./spi.c:	if (spi->cs_gpio >= 0)
./spi.c:		gpio_set_value(spi->cs_gpio, !enable);
./spi.c:	else if (spi->master->set_cs)
./spi.c:		spi->master->set_cs(spi, !enable);
./spi.c:				dev_err(&msg->spi->dev,
./spi.c:				dev_err(&msg->spi->dev,
./spi.c:				dev_err(&msg->spi->dev,
./spi.c:	struct spi_master *master = spi->master;
./spi.c:	rc = of_modalias_node(nc, spi->modalias,
./spi.c:				sizeof(spi->modalias));
./spi.c:	spi->chip_select = value;
./spi.c:	if (of_find_property(nc, "spi-cpha", NULL))
./spi.c:		spi->mode |= SPI_CPHA;
./spi.c:	if (of_find_property(nc, "spi-cpol", NULL))
./spi.c:		spi->mode |= SPI_CPOL;
./spi.c:	if (of_find_property(nc, "spi-cs-high", NULL))
./spi.c:		spi->mode |= SPI_CS_HIGH;
./spi.c:	if (of_find_property(nc, "spi-3wire", NULL))
./spi.c:		spi->mode |= SPI_3WIRE;
./spi.c:	if (of_find_property(nc, "spi-lsb-first", NULL))
./spi.c:		spi->mode |= SPI_LSB_FIRST;
./spi.c:	if (!of_property_read_u32(nc, "spi-tx-bus-width", &value)) {
./spi.c:			spi->mode |= SPI_TX_DUAL;
./spi.c:			spi->mode |= SPI_TX_QUAD;
./spi.c:				"spi-tx-bus-width %d not supported\n",
./spi.c:	if (!of_property_read_u32(nc, "spi-rx-bus-width", &value)) {
./spi.c:			spi->mode |= SPI_RX_DUAL;
./spi.c:			spi->mode |= SPI_RX_QUAD;
./spi.c:				"spi-rx-bus-width %d not supported\n",
./spi.c:	rc = of_property_read_u32(nc, "spi-max-frequency", &value);
./spi.c:		dev_err(&master->dev, "%s has no valid 'spi-max-frequency' property (%d)\n",
./spi.c:	spi->max_speed_hz = value;
./spi.c:	spi->irq = irq_of_parse_and_map(nc, 0);
./spi.c:	spi->dev.of_node = nc;
./spi.c:			spi->chip_select = sb->device_selection;
./spi.c:			spi->max_speed_hz = sb->connection_speed;
./spi.c:				spi->mode |= SPI_CPHA;
./spi.c:				spi->mode |= SPI_CPOL;
./spi.c:				spi->mode |= SPI_CS_HIGH;
./spi.c:	} else if (spi->irq < 0) {
./spi.c:			spi->irq = r.start;
./spi.c:	ACPI_COMPANION_SET(&spi->dev, adev);
./spi.c:	spi->irq = -1;
./spi.c:	if (ret < 0 || !spi->max_speed_hz) {
./spi.c:	strlcpy(spi->modalias, acpi_device_hid(adev), sizeof(spi->modalias));
./spi.c:	if (((spi->mode & SPI_TX_DUAL) && (spi->mode & SPI_TX_QUAD)) ||
./spi.c:		((spi->mode & SPI_RX_DUAL) && (spi->mode & SPI_RX_QUAD))) {
./spi.c:		dev_err(&spi->dev,
./spi.c:	if ((spi->mode & SPI_3WIRE) && (spi->mode &
./spi.c:	bad_bits = spi->mode & ~spi->master->mode_bits;
./spi.c:		dev_warn(&spi->dev,
./spi.c:		spi->mode &= ~ugly_bits;
./spi.c:		dev_err(&spi->dev, "setup: unsupported mode bits %x\n",
./spi.c:	if (!spi->bits_per_word)
./spi.c:		spi->bits_per_word = 8;
./spi.c:	if (!spi->max_speed_hz)
./spi.c:		spi->max_speed_hz = spi->master->max_speed_hz;
./spi.c:	if (spi->master->setup)
./spi.c:		status = spi->master->setup(spi);
./spi.c:	dev_dbg(&spi->dev, "setup mode %d, %s%s%s%s%u bits/w, %u Hz max --> %d\n",
./spi.c:			(int) (spi->mode & (SPI_CPOL | SPI_CPHA)),
./spi.c:			(spi->mode & SPI_CS_HIGH) ? "cs_high, " : "",
./spi.c:			(spi->mode & SPI_LSB_FIRST) ? "lsb, " : "",
./spi.c:			(spi->mode & SPI_3WIRE) ? "3wire, " : "",
./spi.c:			(spi->mode & SPI_LOOP) ? "loopback, " : "",
./spi.c:			spi->bits_per_word, spi->max_speed_hz,
./spi.c:	struct spi_master *master = spi->master;
./spi.c:			|| (spi->mode & SPI_3WIRE)) {
./spi.c:			xfer->bits_per_word = spi->bits_per_word;
./spi.c:			xfer->speed_hz = spi->max_speed_hz;
./spi.c:				!(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
./spi.c:				!(spi->mode & SPI_TX_QUAD))
./spi.c:				!(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
./spi.c:				!(spi->mode & SPI_RX_QUAD))
./spi.c:	struct spi_master *master = spi->master;
./spi.c:	struct spi_master *master = spi->master;
./spi.c:	struct spi_master *master = spi->master;
./spi.c:	struct spi_master *master = spi->master;
./spi.c:		put_device(&spi->dev);
./Kconfig:         will be called spi-dln2.
./spi-rspi.c: * Based on spi-sh.c:
./spi-rspi.c:	iowrite8(data, rspi->addr + offset);
./spi-rspi.c:	iowrite16(data, rspi->addr + offset);
./spi-rspi.c:	iowrite32(data, rspi->addr + offset);
./spi-rspi.c:	return ioread8(rspi->addr + offset);
./spi-rspi.c:	return ioread16(rspi->addr + offset);
./spi-rspi.c:	if (rspi->byte_access)
./spi-rspi.c:	if (rspi->byte_access)
./spi-rspi.c:	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
./spi-rspi.c:	spbr = DIV_ROUND_UP(clk_get_rate(rspi->clk),
./spi-rspi.c:			    2 * rspi->max_speed_hz) - 1;
./spi-rspi.c:	rspi->byte_access = 0;
./spi-rspi.c:	rspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);
./spi-rspi.c:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
./spi-rspi.c:	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
./spi-rspi.c:	spbr = DIV_ROUND_UP(clk_get_rate(rspi->clk),
./spi-rspi.c:			    2 * rspi->max_speed_hz) - 1;
./spi-rspi.c:	rspi->byte_access = 1;
./spi-rspi.c:	rspi->spcmd |= SPCMD_SPB_8_TO_16(access_size);
./spi-rspi.c:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
./spi-rspi.c:	rspi_write8(rspi, rspi->sppcr, RSPI_SPPCR);
./spi-rspi.c:	spbr = DIV_ROUND_UP(clk_get_rate(rspi->clk), 2 * rspi->max_speed_hz);
./spi-rspi.c:	rspi->byte_access = 1;
./spi-rspi.c:		rspi->spcmd |= SPCMD_SPB_8BIT;
./spi-rspi.c:		rspi->spcmd |= SPCMD_SPB_16BIT;
./spi-rspi.c:		rspi->spcmd |= SPCMD_SPB_32BIT;
./spi-rspi.c:	rspi->spcmd |= SPCMD_SCKDEN | SPCMD_SLNDEN | SPCMD_SPNDEN;
./spi-rspi.c:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
./spi-rspi.c:#define set_config_register(spi, n) spi->ops->set_config_register(spi, n)
./spi-rspi.c:	rspi->spsr = rspi_read8(rspi, RSPI_SPSR);
./spi-rspi.c:	if (rspi->spsr & wait_mask)
./spi-rspi.c:	ret = wait_event_timeout(rspi->wait, rspi->spsr & wait_mask, HZ);
./spi-rspi.c:	if (ret == 0 && !(rspi->spsr & wait_mask))
./spi-rspi.c:		dev_err(&rspi->master->dev, "transmit timeout\n");
./spi-rspi.c:		dev_err(&rspi->master->dev, "receive timeout\n");
./spi-rspi.c:	rspi->dma_callbacked = 1;
./spi-rspi.c:	wake_up_interruptible(&rspi->wait);
./spi-rspi.c:		desc_rx = dmaengine_prep_slave_sg(rspi->master->dma_rx,
./spi-rspi.c:		desc_tx = dmaengine_prep_slave_sg(rspi->master->dma_tx,
./spi-rspi.c:		disable_irq(other_irq = rspi->tx_irq);
./spi-rspi.c:	if (rx && rspi->rx_irq != other_irq)
./spi-rspi.c:		disable_irq(rspi->rx_irq);
./spi-rspi.c:	rspi->dma_callbacked = 0;
./spi-rspi.c:		dma_async_issue_pending(rspi->master->dma_rx);
./spi-rspi.c:		dma_async_issue_pending(rspi->master->dma_tx);
./spi-rspi.c:	ret = wait_event_interruptible_timeout(rspi->wait,
./spi-rspi.c:					       rspi->dma_callbacked, HZ);
./spi-rspi.c:	if (ret > 0 && rspi->dma_callbacked)
./spi-rspi.c:		dev_err(&rspi->master->dev, "DMA timeout\n");
./spi-rspi.c:			dmaengine_terminate_all(rspi->master->dma_tx);
./spi-rspi.c:			dmaengine_terminate_all(rspi->master->dma_rx);
./spi-rspi.c:		enable_irq(rspi->tx_irq);
./spi-rspi.c:	if (rx && rspi->rx_irq != other_irq)
./spi-rspi.c:		enable_irq(rspi->rx_irq);
./spi-rspi.c:		dmaengine_terminate_all(rspi->master->dma_rx);
./spi-rspi.c:			     dev_driver_string(&rspi->master->dev),
./spi-rspi.c:			     dev_name(&rspi->master->dev));
./spi-rspi.c:	return xfer->len > rspi->ops->fifo_size;
./spi-rspi.c:	if (rspi->master->can_dma && __rspi_can_dma(rspi, xfer)) {
./spi-rspi.c:				dev_err(&rspi->master->dev, "transmit timeout\n");
./spi-rspi.c:				dev_err(&rspi->master->dev, "receive timeout\n");
./spi-rspi.c:	if (rspi->master->can_dma && __rspi_can_dma(rspi, xfer)) {
./spi-rspi.c:	if (rspi->master->can_dma && __rspi_can_dma(rspi, xfer)) {
./spi-rspi.c:	if (spi->mode & SPI_LOOP) {
./spi-rspi.c:	struct rspi_data *rspi = spi_master_get_devdata(spi->master);
./spi-rspi.c:	rspi->max_speed_hz = spi->max_speed_hz;
./spi-rspi.c:	rspi->spcmd = SPCMD_SSLKP;
./spi-rspi.c:	if (spi->mode & SPI_CPOL)
./spi-rspi.c:		rspi->spcmd |= SPCMD_CPOL;
./spi-rspi.c:	if (spi->mode & SPI_CPHA)
./spi-rspi.c:		rspi->spcmd |= SPCMD_CPHA;
./spi-rspi.c:	rspi->sppcr = 0;
./spi-rspi.c:	if (spi->mode & SPI_LOOP)
./spi-rspi.c:		rspi->sppcr |= SPPCR_SPLP;
./spi-rspi.c:			dev_err(&msg->spi->dev,
./spi-rspi.c:		rspi_write16(rspi, rspi->spcmd | mode, RSPI_SPCMD(i));
./spi-rspi.c:	if (msg->spi->mode &
./spi-rspi.c:	rspi_write16(rspi, rspi->spcmd, RSPI_SPCMD0);
./spi-rspi.c:	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
./spi-rspi.c:		wake_up(&rspi->wait);
./spi-rspi.c:	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
./spi-rspi.c:		wake_up(&rspi->wait);
./spi-rspi.c:	rspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);
./spi-rspi.c:		wake_up(&rspi->wait);
./spi-rspi.c:	rspi_release_dma(rspi->master);
./spi-rspi.c:	{ .compatible = "renesas,rspi-rz", .data = &rspi_rz_ops },
./spi-rspi.c:	rspi->ops = ops;
./spi-rspi.c:	rspi->master = master;
./spi-rspi.c:	rspi->addr = devm_ioremap_resource(&pdev->dev, res);
./spi-rspi.c:	if (IS_ERR(rspi->addr)) {
./spi-rspi.c:		ret = PTR_ERR(rspi->addr);
./spi-rspi.c:	rspi->clk = devm_clk_get(&pdev->dev, NULL);
./spi-rspi.c:	if (IS_ERR(rspi->clk)) {
./spi-rspi.c:		ret = PTR_ERR(rspi->clk);
./spi-rspi.c:	init_waitqueue_head(&rspi->wait);
./spi-rspi.c:			rspi->rx_irq = rspi->tx_irq = ret;
./spi-rspi.c:		rspi->rx_irq = ret;
./spi-rspi.c:			rspi->tx_irq = ret;
./spi-rspi.c:	if (rspi->rx_irq == rspi->tx_irq) {
./spi-rspi.c:		ret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_mux,
./spi-rspi.c:		ret = rspi_request_irq(&pdev->dev, rspi->rx_irq, rspi_irq_rx,
./spi-rspi.c:			ret = rspi_request_irq(&pdev->dev, rspi->tx_irq,
./spi-rspi.c:	{ "rspi-rz",	(kernel_ulong_t)&rspi_rz_ops },
./spi-bitbang.c:	struct spi_bitbang_cs	*cs = spi->controller_state;
./spi-bitbang.c:		bits_per_word = spi->bits_per_word;
./spi-bitbang.c:		hz = spi->max_speed_hz;
./spi-bitbang.c:	struct spi_bitbang_cs	*cs = spi->controller_state;
./spi-bitbang.c:	bitbang = spi_master_get_devdata(spi->master);
./spi-bitbang.c:		spi->controller_state = cs;
./spi-bitbang.c:	cs->txrx_word = bitbang->txrx_word[spi->mode & (SPI_CPOL|SPI_CPHA)];
./spi-bitbang.c:	dev_dbg(&spi->dev, "%s, %u nsec/bit\n", __func__, 2 * cs->nsecs);
./spi-bitbang.c:	kfree(spi->controller_state);
./spi-bitbang.c:	struct spi_bitbang_cs	*cs = spi->controller_state;
./spi-bcm2835.c: * spi-ath79.c, Copyright (C) 2009-2011 Gabor Juhos <juhosg@openwrt.org>
./spi-bcm2835.c: * spi-atmel.c, Copyright (C) 2006 Atmel Corporation
./spi-bcm2835.c:#define DRV_NAME	"spi-bcm2835"
./spi-bcm2835.c:	if (gpio_is_valid(spi->cs_gpio)) {
./spi-bcm2835.c:	if ((spi->mode & SPI_3WIRE) && (tfr->rx_buf))
./spi-bcm2835.c:	if (gpio_is_valid(spi->cs_gpio) || (spi->mode & SPI_NO_CS))
./spi-bcm2835.c:	if (spi->mode & SPI_CPOL)
./spi-bcm2835.c:	if (spi->mode & SPI_CPHA)
./spi-bcm2835.c:	struct spi_master *master = spi->master;
./spi-bcm2835.c:	enable = (spi->mode & SPI_CS_HIGH) ? gpio_level : !gpio_level;
./spi-bcm2835.c:	if (spi->mode & SPI_CS_HIGH) {
./spi-bcm2835.c:		cs |= BCM2835_SPI_CS_CSPOL0 << spi->chip_select;
./spi-bcm2835.c:		cs &= ~(BCM2835_SPI_CS_CSPOL0 << spi->chip_select);
./spi-bcm2835.c:		if (spi->mode & SPI_NO_CS) {
./spi-bcm2835.c:			cs |= spi->chip_select;
./spi-bcm2835.c:	if (spi->mode & SPI_NO_CS)
./spi-bcm2835.c:	if (gpio_is_valid(spi->cs_gpio))
./spi-bcm2835.c:	if (spi->chip_select > 1) {
./spi-bcm2835.c:		dev_err(&spi->dev,
./spi-bcm2835.c:	spi->cs_gpio = chip->base + 8 - spi->chip_select;
./spi-bcm2835.c:	dev_info(&spi->dev, "setting up native-CS%i as GPIO %i\n",
./spi-bcm2835.c:		 spi->chip_select, spi->cs_gpio);
./spi-bcm2835.c:	err = gpio_direction_output(spi->cs_gpio,
./spi-bcm2835.c:				    (spi->mode & SPI_CS_HIGH) ? 0 : 1);
./spi-bcm2835.c:		dev_err(&spi->dev,
./spi-bcm2835.c:			spi->chip_select, spi->cs_gpio, err);
./spi-bcm2835.c:	gpio_set_value(spi->cs_gpio, (spi->mode & SPI_CS_HIGH) ? 0 : 1);
./.spi-fsl-dspi.o.cmd:cmd_drivers/spi/spi-fsl-dspi.o := arm-angstrom-linux-gnueabi-gcc -Wp,-MD,drivers/spi/.spi-fsl-dspi.o.d  -nostdinc -isystem /usr/local/oecore-x86_64/sysroots/x86_64-angstromsdk-linux/usr/lib/arm-angstrom-linux-gnueabi/gcc/arm-angstrom-linux-gnueabi/4.9.3/include -I./arch/arm/include -Iarch/arm/include/generated/uapi -Iarch/arm/include/generated  -Iinclude -I./arch/arm/include/uapi -Iarch/arm/include/generated/uapi -I./include/uapi -Iinclude/generated/uapi -include ./include/linux/kconfig.h -D__KERNEL__ -mlittle-endian -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -std=gnu89 -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mno-thumb-interwork -mfpu=vfp -marm -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -fno-delete-null-pointer-checks -O2 --param=allow-store-data-races=0 -Wframe-larger-than=1024 -fno-stack-protector -Wno-unused-but-set-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -fno-var-tracking-assignments -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -Werror=date-time -DCC_HAVE_ASM_GOTO --sysroot=/usr/local/oecore-x86_64/sysroots/armv7at2hf-vfp-neon-angstrom-linux-gnueabi -DDEBUG    -D"KBUILD_STR(s)=\#s" -D"KBUILD_BASENAME=KBUILD_STR(spi_fsl_dspi)"  -D"KBUILD_MODNAME=KBUILD_STR(spi_fsl_dspi)" -c -o drivers/spi/.tmp_spi-fsl-dspi.o drivers/spi/spi-fsl-dspi.c
./.spi-fsl-dspi.o.cmd:source_drivers/spi/spi-fsl-dspi.o := drivers/spi/spi-fsl-dspi.c
./.spi-fsl-dspi.o.cmd:deps_drivers/spi/spi-fsl-dspi.o := \
./.spi-fsl-dspi.o.cmd:drivers/spi/spi-fsl-dspi.o: $(deps_drivers/spi/spi-fsl-dspi.o)
./.spi-fsl-dspi.o.cmd:$(deps_drivers/spi/spi-fsl-dspi.o):
./spi-fsl-espi.c:#include "spi-fsl-lib.h"
./spi-fsl-espi.c:	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
./spi-fsl-espi.c:	struct spi_mpc8xxx_cs *cs = spi->controller_state;
./spi-fsl-espi.c:	struct fsl_espi_reg *reg_base = mspi->reg_base;
./spi-fsl-espi.c:	__be32 __iomem *mode = &reg_base->csmode[spi->chip_select];
./spi-fsl-espi.c:	const u32 *tx = mpc8xxx_spi->tx;
./spi-fsl-espi.c:	data = *tx++ << mpc8xxx_spi->tx_shift;
./spi-fsl-espi.c:	mpc8xxx_spi->tx = tx;
./spi-fsl-espi.c:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
./spi-fsl-espi.c:	struct spi_mpc8xxx_cs *cs = spi->controller_state;
./spi-fsl-espi.c:		bits_per_word = spi->bits_per_word;
./spi-fsl-espi.c:		hz = spi->max_speed_hz;
./spi-fsl-espi.c:		if (spi->mode & SPI_LSB_FIRST)
./spi-fsl-espi.c:	mpc8xxx_spi->rx_shift = cs->rx_shift;
./spi-fsl-espi.c:	mpc8xxx_spi->tx_shift = cs->tx_shift;
./spi-fsl-espi.c:	mpc8xxx_spi->get_rx = cs->get_rx;
./spi-fsl-espi.c:	mpc8xxx_spi->get_tx = cs->get_tx;
./spi-fsl-espi.c:	if ((mpc8xxx_spi->spibrg / hz) > 64) {
./spi-fsl-espi.c:		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 16 * 4);
./spi-fsl-espi.c:			  "Will use %d Hz instead.\n", dev_name(&spi->dev),
./spi-fsl-espi.c:				hz, mpc8xxx_spi->spibrg / (4 * 16 * (32 + 1)));
./spi-fsl-espi.c:		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 4);
./spi-fsl-espi.c:	struct fsl_espi_reg *reg_base = mspi->reg_base;
./spi-fsl-espi.c:	mspi->count = len;
./spi-fsl-espi.c:	word = mspi->get_tx(mspi);
./spi-fsl-espi.c:	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
./spi-fsl-espi.c:	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
./spi-fsl-espi.c:	mpc8xxx_spi->len = t->len;
./spi-fsl-espi.c:	mpc8xxx_spi->tx = t->tx_buf;
./spi-fsl-espi.c:	mpc8xxx_spi->rx = t->rx_buf;
./spi-fsl-espi.c:	reinit_completion(&mpc8xxx_spi->done);
./spi-fsl-espi.c:		dev_err(mpc8xxx_spi->dev, "Transaction length (%d)"
./spi-fsl-espi.c:		(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));
./spi-fsl-espi.c:	wait_for_completion(&mpc8xxx_spi->done);
./spi-fsl-espi.c:	return mpc8xxx_spi->count;
./spi-fsl-espi.c:	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
./spi-fsl-espi.c:			dev_err(mspi->dev,
./spi-fsl-espi.c:	if (!spi->max_speed_hz)
./spi-fsl-espi.c:	mpc8xxx_spi = spi_master_get_devdata(spi->master);
./spi-fsl-espi.c:	reg_base = mpc8xxx_spi->reg_base;
./spi-fsl-espi.c:			&reg_base->csmode[spi->chip_select]);
./spi-fsl-espi.c:	if (spi->mode & SPI_CPHA)
./spi-fsl-espi.c:	if (spi->mode & SPI_CPOL)
./spi-fsl-espi.c:	if (!(spi->mode & SPI_LSB_FIRST))
./spi-fsl-espi.c:	if (spi->mode & SPI_LOOP)
./spi-fsl-espi.c:	struct fsl_espi_reg *reg_base = mspi->reg_base;
./spi-fsl-espi.c:		while (SPIE_RXCNT(events) < min(4, mspi->len)) {
./spi-fsl-espi.c:		if (mspi->len >= 4) {
./spi-fsl-espi.c:			tmp = mspi->len;
./spi-fsl-espi.c:			rx_data <<= (4 - mspi->len) * 8;
./spi-fsl-espi.c:		mspi->len -= 4;
./spi-fsl-espi.c:		if (mspi->rx)
./spi-fsl-espi.c:			mspi->get_rx(rx_data, mspi);
./spi-fsl-espi.c:			dev_err(mspi->dev, "tired waiting for SPIE_NF\n");
./spi-fsl-espi.c:	mspi->count -= 1;
./spi-fsl-espi.c:	if (mspi->count) {
./spi-fsl-espi.c:		u32 word = mspi->get_tx(mspi);
./spi-fsl-espi.c:		complete(&mspi->done);
./spi-fsl-espi.c:	struct fsl_espi_reg *reg_base = mspi->reg_base;
./spi-fsl-espi.c:	dev_vdbg(mspi->dev, "%s: events %x\n", __func__, events);
./spi-fsl-espi.c:	iounmap(mspi->reg_base);
./spi-fsl-espi.c:	reg_base = mpc8xxx_spi->reg_base;
./spi-fsl-espi.c:	reg_base = mpc8xxx_spi->reg_base;
./spi-fsl-espi.c:	mpc8xxx_spi->spi_remove = fsl_espi_remove;
./spi-fsl-espi.c:	mpc8xxx_spi->reg_base = ioremap(mem->start, resource_size(mem));
./spi-fsl-espi.c:	if (!mpc8xxx_spi->reg_base) {
./spi-fsl-espi.c:	reg_base = mpc8xxx_spi->reg_base;
./spi-fsl-espi.c:	ret = request_irq(mpc8xxx_spi->irq, fsl_espi_irq,
./spi-fsl-espi.c:	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE) {
./spi-fsl-espi.c:		mpc8xxx_spi->rx_shift = 16;
./spi-fsl-espi.c:		mpc8xxx_spi->tx_shift = 24;
./spi-fsl-espi.c:	dev_info(dev, "at 0x%p (irq = %d)\n", reg_base, mpc8xxx_spi->irq);
./spi-fsl-espi.c:	free_irq(mpc8xxx_spi->irq, mpc8xxx_spi);
./spi-fsl-espi.c:	iounmap(mpc8xxx_spi->reg_base);
./spi-fsl-espi.c:	prop = of_get_property(np, "fsl,espi-num-chipselects", &len);
./spi-fsl-espi.c:		dev_err(dev, "No 'fsl,espi-num-chipselects' property\n");
./spi-fsl-espi.c:	reg_base = mpc8xxx_spi->reg_base;
./spi-pxa2xx-dma.c:#include "spi-pxa2xx.h"
./spi-pxa2xx-dma.c:	struct pxa2xx_spi_chip *chip_info = spi->controller_data;
./spi-orion.c:	return orion_spi->base + reg;
./spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
./spi-orion.c:	devdata = orion_spi->devdata;
./spi-orion.c:	tclk_hz = clk_get_rate(orion_spi->clk);
./spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
./spi-orion.c:	if (spi->mode & SPI_CPOL)
./spi-orion.c:	if (spi->mode & SPI_CPHA)
./spi-orion.c:	unsigned int speed = spi->max_speed_hz;
./spi-orion.c:	unsigned int bits_per_word = spi->bits_per_word;
./spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
./spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
./spi-orion.c:				ORION_SPI_CS(spi->chip_select));
./spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
./spi-orion.c:		dev_err(&spi->dev, "TXS timed out\n");
./spi-orion.c:	orion_spi = spi_master_get_devdata(spi->master);
./spi-orion.c:		dev_err(&spi->dev, "TXS timed out\n");
./spi-orion.c:	word_len = spi->bits_per_word;
./spi-orion.c:	spi->master = master;
./spi-orion.c:	spi->devdata = devdata;
./spi-orion.c:	spi->clk = devm_clk_get(&pdev->dev, NULL);
./spi-orion.c:	if (IS_ERR(spi->clk)) {
./spi-orion.c:		status = PTR_ERR(spi->clk);
./spi-orion.c:	status = clk_prepare_enable(spi->clk);
./spi-orion.c:	tclk_hz = clk_get_rate(spi->clk);
./spi-orion.c:	spi->base = devm_ioremap_resource(&pdev->dev, r);
./spi-orion.c:	if (IS_ERR(spi->base)) {
./spi-orion.c:		status = PTR_ERR(spi->base);
./spi-orion.c:	clk_disable_unprepare(spi->clk);
./spi-orion.c:	clk_disable_unprepare(spi->clk);
./spi-orion.c:	clk_disable_unprepare(spi->clk);
./spi-orion.c:	return clk_prepare_enable(spi->clk);
./spi-omap-uwire.c:	struct	uwire_state *ust = spi->controller_state;
./spi-omap-uwire.c:	if (value == BITBANG_CS_INACTIVE || old_cs != spi->chip_select) {
./spi-omap-uwire.c:		if (spi->mode & SPI_CPOL)
./spi-omap-uwire.c:		w = spi->chip_select << 10;
./spi-omap-uwire.c:	unsigned	bits = t->bits_per_word ? : spi->bits_per_word;
./spi-omap-uwire.c:	w = spi->chip_select << 10;
./spi-omap-uwire.c:					dev_name(&spi->dev), bits, val);
./spi-omap-uwire.c:					dev_name(&spi->dev), bits, val);
./spi-omap-uwire.c:	struct uwire_state	*ust = spi->controller_state;
./spi-omap-uwire.c:	uwire = spi_master_get_devdata(spi->master);
./spi-omap-uwire.c:	if (spi->mode & SPI_CS_HIGH)
./spi-omap-uwire.c:	if (spi->mode & SPI_CPOL)
./spi-omap-uwire.c:	switch (spi->mode & (SPI_CPOL | SPI_CPHA)) {
./spi-omap-uwire.c:	hz = spi->max_speed_hz;
./spi-omap-uwire.c:		pr_debug("%s: zero speed?\n", dev_name(&spi->dev));
./spi-omap-uwire.c:			dev_name(&spi->dev), rate / 10 / 8, hz);
./spi-omap-uwire.c:	omap_uwire_configure_mode(spi->chip_select, flags);
./spi-omap-uwire.c:	struct uwire_state *ust = spi->controller_state;
./spi-omap-uwire.c:		spi->controller_state = ust;
./spi-omap-uwire.c:	kfree(spi->controller_state);
./spi-omap-uwire.c:	/* the spi->mode bits understood by this driver: */
